### [Разделяемые ресурсы и асинхронные блокировки][sdk-shared-resources]

Другой важный паттерн, который мы должны рассмотреть — это доступ к общим ресурсам. Предположим, что в нашем учебном приложении разработчик решил открывать экран предложения с анимацией. Для этого он воспользуется объектом offerPanel, который мы реализуем в составе searchBox:

```
class OfferPanel {
  constuctor(searchBox) {
    searchBox.on(
      'selectOffer',
      (event) => {
        // Показываем выбранное предложение
        // в панели, но размещаем её
        // за границей экрана
        this.render(event.offer, {
          left: screenWidth
        });
        // Анимируем положение панели
        this.animate(
          'left', 0, '1s'
        );
      }
    );
  }
}
```

Возникает вопрос: а что должно произойти, если, например, пользователь пытается прокрутить список предложений, и сейчас происходит анимация панели? Логически мы должны эту операцию запретить, поскольку в ней нет никакого смысла — выезжающая панель всё равно не даст просмотреть новые элементы списка. Мы можем изменить *состояние* компонента, выставив флаг «происходит анимация»:

```
searchBox.on('selectOffer', (offer) {
  searchBox.offerPanel.render(offer, {
    left: screenWidth
  });

  searchBox.state.isAnimating = true;

  await searchBox.offerPanel
    .view.animate('left', 0, '1s');

  searchBox.state.isAnimating = false;
});

searchBox.on('scroll', (event) => {
  // Если сейчас происходит анимация
  if (searchBox.state.isAnimating) {
    // Запретить действие
    return false;
  }
});
```

Но этот код очень плох по множеству причин:
  * непонятно, как его модифицировать, если у нас появятся разные виды анимации, причём некоторые из них будут требовать блокировки прокрутки, а некоторые — нет;
  * этот код просто плохо читается: совершенно непонятно, почему флаг `isAnimating` влияет на обработку события `scroll`;
  * сложно предсказать, что произойдёт, если каким-то образом (например, программно) будет открыто другое предложение — оба процесса будут «драться» за один флаг и один объект;
  * если при выполнении анимации произойдёт какая-то ошибка, флаг `isAnimating` не будет сброшен, и прокрутка будет заблокирована навсегда.

Корректное решение первых двух проблемы — это абстрагирование от самого факта анимации и переформулирование проблемы в высокоуровневых терминах. Почему мы запрещаем прокрутку во время анимации? Потому что появление панели предложения как бы «захватывает» эту область экрана. Пользователь не может работать с другими объектами в этой области во время анимации (или, скорее, нет разумного сценария использования, при котором пользователю может понадобиться это делать). Следовательно, именно такой флаг нам и надо объявить — признак «разделяемая область на экране заблокирована»:

```
searchBox.on('selectOffer', (offer) {
  searchBox.offerPanel.render(offer, {
    left: screenWidth
  });

  searchBox.state.
    isInnerAreaLocked = true;

  await searchBox.offerPanel
    .view.animate('left', 0, '1s');

  searchBox.state.
    isInnerAreaLocked = false;
});

searchBox.on('scroll', (event) => {
  // Если сейчас происходит анимация
  if (searchBox.state
    .isInnerAreaLocked) {
    // Запретить действие
    return false;
  }
});
```

Такой подход улучшает семантику операций, но не помогает с проблемами параллельного доступа и ошибочно неснятых флагов. Чтобы решить их, нам нужно сделать ещё один шаг: не просто ввести флаг, но и процедуру его *захвата* (вполне классическим образом по аналогии с управлением разделяемыми ресурсами в системном программировании):

```
try {
  const lock = await searchBox
    .state.acquireLock('innerArea', '2s');

  await searchBox.offerPanel
    .view.animate('left', 0, '1s');
  
  lock.release();
} catch (e) {
  // Какая-то логика обработки
  // невозможности захвата ресурса
  …
}
```

**NB**: вторым параметром в `acquireLock` мы передали время жизни блокировки — 2 секунды. Если в течение двух секунд блокировка не снята, она будет отменена автоматически.

В таком подходе мы можем реализовать не только блокировки, но и программируемые прерывания и реакцию на них:

```
const lock = await searchBox
  .state.acquireLock(
    'innerArea', 
    '2s', {
      // Добавляем описание,
      // кто и зачем пытается
      // выполнить блокировку
      reason: 'selectOffer',
      offer
    }
  );

lock.on('lost', () => {
  // Если у нас забрали блокировку,
  // отменяем анимацию
  searchBox.offerPanel.view
    .cancelAnimation();
})

// Если другой актор пытается
// перехватить блокировку
lock.on('tryLock', (sender) => {
  // Если это другое предложение,
  // разрешааем перехват и отменяем
  // текущую блокировку
  if (sender.reason == 'selectOffer') {
    lock.release();
  } else {
    // Иначе запрещаем перехват
    return false;
  }
})

await searchBox.offerPanel
  .view.animate('left', 0, '1s');

lock.release();
```

**NB**: хотя пример выше выглядит крайне переусложнённым, в нём не учтено ещё множество нюансов:
  * `offerPanel` тоже должен стать разделяемым ресурсом, и его точно так же надо захватывать;
  * при перехвате блокировки должна останавливаться не анимация вообще, а та конкретная операция, которая была запущена в рамках конкретной блокировки.

Упражнение «найти все разделяемые ресурсы и дополнить пример корректной работой с ними» мы оставим читателю.