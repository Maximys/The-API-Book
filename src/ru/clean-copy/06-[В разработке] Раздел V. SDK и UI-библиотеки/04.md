### [Декомпозиция UI-компонентов][sdk-decomposing]

Перейдём к более предметному разговору и попробуем объяснить, почему требование возможности замены одной из подсистем компонента (внешнего вида, бизнес-логики или поведения) приводит к кратному усложнению интерфейсов. Продолжим рассматривать пример компонента `SearchBox` из предыдущей главы. Напомним, что мы выделили следующие факторы, осложняющие проектирование API визуальных компонентов:
  * объединение в одном объекте разнородной функциональности, а именно — бизнес-логики, настройки внешнего вида и поведения компонента;
  * появление разделяемых ресурсов, т.е. состояния объекта, которое могут одновременно читать и модифицировать разные акторы (включая конечного пользователя);
  * неоднозначность иерархий наследования свойств и опций компонентов.

Сделаем задачу более конкретной, и попробуем разработать наш `SearchBox` так, чтобы он допускал следующие модификации:
  1. Замена списочного представления предложений, например, на представление в виде карты с подсвечиваемыми метками:
      * иллюстрирует проблему полной замены одного субкомпонента (списка заказов) при сохранении поведения и дизайна остальных частей системы, а также сложности имплементации разделяемого состояния;

      [![APP](/img/mockups/05.png "Результаты поиска на карте")]()

  2. Добавление кнопки быстрого заказа в каждое предложение в списке:
      * иллюстрирует проблему полного удаления одного из субкомпонентов при сохранении бизнес-логики и UX:

      [![APP](/img/mockups/06.png "Список результатов поиска с кнопками быстрых действий")]()

  3. Брендирование предложения и кнопки заказа иконкой сети кофеен:
      * иллюстрирует проблемы неоднозначности иерархий наследования и разделяемых ресурсов (иконки кнопки), как описано в предыдущей главе;

      [![APP](/img/mockups/07.png "Дополнительная кнопка «Позвонить»")]()

Решение, которое напрашивается в данной ситуации — это выделение двух дополнительных компонентов, отвечающих за представление списка предложений и за панель показа конкретного предложения, которые можно будет кастомизировать под конкретную задачу. Например, мы можем реализовать связь между ними следующим образом:

```
class SearchBox {
  // Компонент списка предложений
  public offerList: OfferList;
  // Панель отображения
  // выбранного предложения
  public offerPanel: OfferPanel;

  // Инициализация
  setupComponents() {
    // Подписываемся на клик по
    // предложению
    this.offerList.events.on(
      'click', 
      (event) => {
        this.selectedOffer =
          event.target.offer;
        this.offerPanel.show(
          this.selectedOffer
        );
      });
    this.offerPanel.on(
      'click', () => {
        this.createOrder();
      }
    )
  }

  // Ссылка на текущее выбранное предложение
  private selectedOffer: Offer;
  // Создаёт заказ
  private createOrder() {
    const order = await api
      .createOrder(this.selectedOffer);
    // Действия после создания заказа
    …
  }
  …
}
```

В данном фрагменте кода налицо полный хаос с уровнями абстракции, и заодно сделано множество неявных предположений:
  * единственный способ выбрать предложение — клик по элементу списка;
  * единственный способ сделать заказ — клик внутри элемента «панель предложения»;
  * заказ не может быть сделан, если предложение не было предварительно выбрано.

Из поставленных нами задач при такой декомпозиции мы можем условно решить только вторую (замена списка на карту), потому что к решению первой и четвёртой проблемы (настройка кнопок в панели) мы не продвинулись вообще, а третью (кнопки быстрых действий в списке заказов) можно решить только следующим образом: 
  * сделать панель заказа невидимой / перенести её за границы экрана;
  * после события `"click"` на кнопке создания заказа дождаться окончания отрисовки невидимой панели и сгенерировать на ней фиктивное событие `"click"`.

Думаем, излишне уточнять, что подобные решения ни в каком случае не могут считать разумным API для UI-компонента. Но как же нам всё-таки *сделать* этот интерфейс расширяемым?

Первая очевидная проблема заключается в том, что `SearchBox` должен реагировать на низкоуровневые события типа `click`. Согласно рекомендациям, данным нами в главе «[Слабая связность](#back-compat-weak-coupling)», мы должны сделать его контекстом для нижележащих сущностей, а для этого нам нужно в первую очередь установить, что же он из себя представляет *логически*, какова его область ответственности как компонента?

Предположим, что мы определим `SearchBox` концептуально как конечный автомат, находящийся в одном из трёх состояний:
  1. Пуст (ожидает запроса пользователя и получения списка предложений).
  2. Показан список предложений по запросу.
  3. Показано конкретное предложение пользователю.
  4. Создаётся заказ.

Соответствующие интерфейсы должны быть и предъявлены субкомпонентам: они должны нотифицировать об одном из переходов. Соответственно, `SearchBox` должен ждать не события `click`, а событий типа `selectOffer` и `createOrder`:

```
this.offerList.on(
  'selectOffer', 
  (event) => {
    this.selectedOffer =
      event.offer;
    this.offerPanel.show(
      this.selectedOffer
    );
  });
this.offerPanel.on(
  'createOrder', () => {
    this.createOrder();
  }
)
```

Возможности по кастомизации субкомпонентов расширились: теперь нет нужды эмулировать `'click'` для выбора предложения, есть семантический способ сделать это через событие `selectOffer`; аналогично, какие события обрабатывает панель предложения для бросания события `createOrder` — больше не забота самого `SearchBox`-а.

Однако описанный выше пример — с заказом свайпом по элементу списка — всё ещё реализуется «костыльно» через открытие невидимой панели, поскольку вызов `offerPanel.show` всё ещё жёстко вшит в сам `SearchBox`. Мы можем сделать ещё один шаг, и сделать связность ещё более слабой: пусть `SearchBox` не вызывает напрямую методы субкомпонентов, а только извещает об изменении собственного состояния:

```
this.offerList.on(
  'selectOffer', 
  (event) => {
    this.selectedOffer =
      event.offer;
    this.emit('stateChange', {
      selectedOffer: this.
        selectedOffer
    });
  });
this.offerPanel.on(
  'createOrder', () => {
    const order = await api.createOrder();
    this.state = 'orderCreated';
    this.emit('stateChange', {
      order
    });
  }
)
```

Тем самым мы даём имплементациям компонентов бо́льшую свободу действий. `offerPanel` не обязана «открываться», если такого состояния в ней нет и может просто проигнорировать изменения состояния на `offerSelected`. Наконец, мы могли бы полностью абстрагироваться от нижележащего UI, если сделаем `SearchBox` транслятором несущественного для него события `"selectOffer"`:

```
// Имплементация SearchBox
class SearchBox {
  …
  public onMessage(message) {
    switch (message.type) {
      case 'selectOffer':
        this.emit('stateChange', {
          selectedOffer: message.offer
        });
        break;
      …
    }
  }
  …
};
// Имплементация OfferList
class OfferList {
  public context: SearchBox;
  onOfferClick(offer) {
    // Компонент-список предложений
    // инициирует выбор конкретного
    // предложения через нотификацию
    // родительского контекста
    this.context.onMessage({
        type: 'selectOffer',
        offer
    });
  }
  …
}
```

Это решение выглядит достаточно общим и в своём роде идеальным (`SearchBox` сведён к своей чистой функциональности — получению списка предложений по запросу пользователя), но при этом является, увы, очень ограниченно применимым:
  * он содержит очень мало функциональности, которая реально помогала бы программисту в его работе;
  * он включает функциональность трансляции событий, которые ничего не значат для самого `SearchBox` и являются очевидно излишними на этом уровне;
  * он заставляет программиста досконально разобраться в механике работы каждого субкомпонента и имплементировать её полностью, если необходима альтернативная реализация.

Или, если сформулировать другими словами, наш `SearchBox` не «перекидывает мостик», не сближает два программных контекста (высокоуровневый `SearchBox` и низкоуровневую имплементацию, скажем, `offerPanel`-а). Пусть, например, разработчик хочет сделать не сложную замену UX, а очень простую вещь: сменить дизайн кнопки «Заказать» на какой-то другой. Проблема заключается в том, что альтернативная кнопка не бросает никаких событий `'createOrder'` — она генерирует самый обычный `'click'`. А значит, разработчику придётся написать эту логику самостоятельно.

```
class MyOfferPanel implements IOfferPanel {
  protected parentSearchBox;

  render() {
    this.button = new CustomButton();
    this.button.on('click', () => {
      this.parentSearchBox.notify(
        'createOrder'
      )
    });
  }
}
```

В нашем примере это не выглядит чем-то сложным (но это только потому, что наш конечный автомат очень прост и содержит очень мало данных), но трудно не согласиться с тем, что необходимость писать подобный код совершенно неоправдана: почти любая альтернативная реализация кнопки генерирует именно событие `'click'`.

Другая очень большая проблема состоит в том, что с подобным «плоским» интерфейсом (любой актор может отправить события `selectOffer` / `createOrder`) мы фактически просто перевернули дырявую изоляцию абстракций с ног на голову: раньше `SearchBox` должен был знать о низкоуровневых объектах и их поведении — теперь низкоуровневые объекты должны знать о логике работы `SearchBox`. Такая перевёрнутая пирамида лучше прямой (нам хотя бы не приходится эмулировать клики на скрытых объектах), но далеко не идеальна с точки зрения архитектуры конкретного приложения. Написанный в этой парадигме код практически невозможно использовать повторно (приведённый выше пример `MyOfferPanel` нельзя использовать для каких-либо других целей, потому что действие по клику на кнопку всегда одно и то же — создание заказа), что приводит к необходимости копипастинга кода со всеми вытекающими проблемами.

Мы можем решить и эту проблему, если искусственным образом «перекинем мостик» — введём дополнительный уровень абстракции (назовём его, скажем, «арбитром»), который позволяет транслировать контексты:

```
class Arbiter implements IArbiter {
  protected currentSelectedOffer;

  constructor(
    searchBox: ISearchBox,
    offerPanel: IOfferPanel
  ) {
    // Панель показа предложений
    // должна быть каким-то образом
    // привязана к арбитру
    offerPanel.setArbiter(this);
    
    searchBox.on('stateChange', (event) => {
      // Арбитр переформулирует события
      // `searchBox` в требования к
      // панели предложений.

      // Если выбрано новое предложение
      if (this.currentSelectedOffer !=
        event.offer) {
        // Запоминаем предложение
        this.currentSelectedOffer =
          event.offer;
        // Даём команду на открытие панели
        this.emit('showPanel', {
          content: this.generateOfferContent(
            this.currentSelectedOffer
          )
        });
      }
    });

    // Если же от кнопки создания заказа
    // пришло событие 'click'
    this.offerPanel.createOrderButton.on(
      'click',
      () => {
        this.searchBox.notify('createOrder');
      }
    );
  }

  protected generateOfferContent(offer) {
    // Формирует контент панели
    …
  }
}
```

Таким образом, мы убрали сильную связность компонентов: можно отдельно переопределить класс кнопки создания заказа (достаточно, чтобы он генерировал событие `'click'`) и даже саму панель целиком. Вся *специфическая* логика, относящаяся к работе панели показа приложений, теперь собрана в арбитре — саму панель можно переиспользовать в других частях приложения.

Более того, мы можем пойти дальше и сделать два уровня арбитров — между `SearchBox` и панелью предложений и между панелью предложений и кнопкой создания заказа. Тогда у нас пропадёт требование к `IOfferPanel` иметь поле `createOrderButton`, и мы сможем свободно комбинировать разные варианты: альтернативный способ подтверждения заказа (не по кнопке), альтернативная реализация панели с сохранением той же кнопки и т.д.

Единственной проблемой остаётся потрясающая сложность и неочевидность имплементации такого решения со всеми слоями промежуточных арбитров. Таков путь.
