### MV*-фреймворки

Очевидным способом сделать менее сложными многослойные схемы, подобные описанным в предыдущей главе, является ограничение возможных путей взаимодействия между компонентами. Как мы описывали в главе «Слабая связность», мы могли бы упростить код, если бы разрешили нижележащим субкомпонентам напрямую вызывать методы вышестоящих сущностей. Например, так:

```
class Arbiter implements IArbiter {
  protected currentSelectedOffer;

  constructor(
    searchBox: ISearchBox,
    offerPanel: IOfferPanel
  ) {
    …    
    this.offerPanel.createOrderButton.on(
      'click',
      () => {
        // Вместо оповещения о событии,
        // напрямую вызываем родительский
        // метод
        this.searchBox.createOrder();
      }
    );
  }
}
```

Кроме того, мы можем использовать арбитр только для передачи сигналов от UI, а с данными взаимодействовать напрямую:

```
class OfferPanel {
  protected currentSelectedOffer;

  constructor(
    searchBox: ISearchBox,
  ) {
    // Панель показа предложений
    // сама получает нужные
    // ей данные
    searchBox.on('stateChange', (event) => {
      if (this.currentSelectedOffer !=
        event.offer) {
        this.currentSelectedOffer =
          event.offer;
        this.show({
          content: this.generateOfferContent(
            this.currentSelectedOffer
          )
        });
      }
    });
  }
}
```

Тем самым мы утратили возможность переиспользовать саму панель (она содержит логику, опирающуюся на получение конкретного вида данных), но сохранили возможность свободно использовать альтернативные реализации компонентов панели (мы всё ещё превращаем `'click'` на кнопке создания заказа в действие на уровне арбитра, не модифицируя код самой кнопки). Как бонус мы получили отсутствие двусторонних взаимодействий между тремя нашими сущностями: кнопка *читает* состояние `SearchBox`-а, но не модифицирует его; контроллер *читает* состояние `OfferPanel`, но не модифицирует его; сам `SearchBox` вообще никак не взаимодействует ни с тем, ни с другим — только лишь инстанцирует в нужный момент.

Сделав подобное упрощение, мы фактически получили компонент, следующий методологии [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller): `OfferPanel` — это view, который непосредственно взаимодействует с пользователем и оповещает об этом событиями, `Arbiter` — это controller, который получает события от view и модифицирует модель (сам `SearchBox`). Если мы выберем другие направления редукции полного взаимодействия, мы получим другие варианты MV*-фреймворков (Model—View—View model, Model—View—Presenter и т.д.) Все они, в конечно счёте, предлагают реализовать следующий подход:

  1. Выделить сущность *модель*, отвечающую за данные, поверх которых построен компонент.
  2. Потребовать, чтобы внешний вид и поведение компонента полностью определялись его моделью.
  3. Построить механизм изменений внешнего вида компонента через изменение модели.
  4. Запретить взаимодействия, которые не соответствуют выбранному способу разделения компонента (например, в MVC view запрещено изменять состояние модели напрямую).

(схемы MVC, MVP, MVVP)

Достоинством MV*-подходов и иных способов ограничения сложности субкомпонентного взаимодействия (например, Redux также является одним из подходов, хотя он оставляет реализацию view за скобками) является строгое насаждение уровней абстракции, которое упрощает дизайн API и вообще оставляет меньше возможностей сделать в нём ошибку. Один очевидный недостаток всех этих фреймворков мы упомянули — это фиксация явных интерфейсов (в нашем случае — контроллер напрямую вызывает методы `SearchBox`-а), что означает ограничение возможности замены составляющих на альтернативные имплементации. Второй очевидный недостаток мы рассмотрим ниже.

#### Паттерн «модель»

Общая черта, объединяющая все MV*-фреймворки — это выделение сущности «модель» (некоторого набора данных), которая детерминировано *определяет* внешний вид и состояние UI-компонента. Изменения в модели порождают и изменения в отображении компонента (или дерева компонентов; модель может быть одной на всё приложение, и полностью определять весь интерфейс).

У этого подхода есть несколько очень важных свойств:
  * он позволяет восстанавливать состояние в случае ошибок (например, сбоя в рендеринге или перезагрузки приложения);
  * любые переходы между состояниями можно рассматривать как применение изменения (патча) к модели, что, помимо прочего, позволят «возвращаться в прошлое», т.е. отменять последние действия.

Один из частных случаев использование модели — это сериализация её в виде URL (или App Links в случае мобильных приложений). Тогда URL полностью определяет состояние приложения, и любые изменения состояния отражаются в виде изменений URL. Этот подход чрезвычайно удобен тем, что можно сгенерировать специальные ссылки, открывающие нужный экран в приложении.

Недостатки этого подхода, увы, также очевидны:
  * если задаться целью *полностью* описать состояние компонента, то мы обязаны внести в него и такие данные, как выполняющиеся сейчас анимации и даже процент их выполнения — очевидно, на таком уровне детализации ни о каком хранении модели в виде набора патчей речи идти не может, так как нам придётся сохранить каждый шаг анимации;
  * таким образом, модель обязана будет содержать в себе все данные всех уровней абстракции (причём, зачастую, дублирующие друг друга — например, контент панели предложения является производной от показанного предложения), и, более того, каким-то образом включать в себя две или более иерархии подчинения (по семантической и визуальной иерархиям, а так же, возможно, все селекторы и правила, как мы описали их в главе «Вычисляемые свойства»).

В нашем примере это означает, например, что модель должна будет хранить `currentSelectedOffer` для `SearchPanel`, иначе в коде панели невозможно будет определить, изменилось ли выбранное предложение.

Подобная полная модель представляет собой проблему не только теоретически и семантически (перемешивание в одной сущности разнородных данных), но и в практическом смысле — сериализация таких моделей окажется ограничена рамками конкретной версии API или приложения. Если мы в следующей версии изменим реализацию панели, то старые ссылки перестанут работать (либо нам потребуется держать слой совместимости, описывающий, как интерпретировать модели предыдущих версий).

В практическом смысле, разумеется, разработчики визуальных SDK и не пытаются строить такие модели, описывающие до последней запятой состояние каждого субкомпонента в дереве; модели состоят из *важных* полей, а всё «неважное» остаётся на откуп другим частям системы. (Что, по факту, означает следующее: UI-библиотеки никогда не реализуют MV*-подходы *строго*, поскольку это попросту невозможно. View-компоненты всегда имеют свои скрытые состояния-субмодели, которые лишь частично согласованы с основной моделью — в том числе потому, что далеко не всегда возможно это согласование произвести синхронно.)
