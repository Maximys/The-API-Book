### Декомпозиция UI-компонентов. MV*-подходы

Сложность решения проблем, описанных в предыдущей главе, заключается прежде всего в том, что почти любой объект вложен в две (а то и три) различные иерархии сущностей. Если мы возьмём объект «кнопка создания заказа», то она:
  * вложена в иерархию визуальных сущностей: экран → `SearchBox` → компонент «просмотр предложения» → компонент «панель действий»;
  * привязана к некоторой сущности внутри иерархии данных (результату поиска);
  * как программный объект является наследником каких-то базовых классов, отвечающих за UX (системного объекта типа «кнопка», который является реализацией системного интерфейса «интерактивный элемент» и так далее).

Как мы помним из главы «Разделение уровней абстракции», объединение в одном объекте двух-трёх-четырёх разноплановых контекстов — чрезвычайно деструктивное решение, которое приводит к «перепрыгиваниям» по областям ответственности и, как следствие, переусложнённому коду, в рамках которого разработчику придётся манипулировать множеством самых разных сущностей из самых отдалённых фрагментов документации. Увы, с визуальными компонентами у нас просто нет другого выбора: наша кнопка действительно является таким многомерным контекстом, если мы хотим дать возможность гибко настраивать её внешний вид, UX и бизнес-логику. Таков путь.

Можно легко продемонстрировать, как пересечение нескольких предметных областей в одном объекте быстро приводит к крайне запутанной и неочевидной логике. Например, представим себе следующую функциональность: если в данных предложения есть поле `checkoutButtonIconUrl`, то иконка будет взята из этого поля — вполне разумное соглашение, если мы хотим позволить выставлять на кнопке иконку сети кофеен, в которой делается заказ. Но тогда разработчик сможет её кастомизировать и показывать не сеть кофеен, а какую-то свою фирменную иконку для действия «заказ», подменив в данных поле `checkoutButtonIconUrl` для каждого результата поиска:

```
const searchBox = new SearchBox({
  // Предположим, что мы разрешили
  // переопределять поисковую функцию
  searchApi: function (params) {
    const res = await api.search(params);
    res.forEach((item) {
        item.checkoutButtonIconUrl = 
          <URL нужной иконки>;
    });
    return res;
  }
}
```

*Формально* этот подход корректен и никаких рекомендаций не нарушает. Но с точки зрения связности кода, его читабельности — это полная катастрофа, поскольку следующий разработчик, которого попросят заменить иконку *кнопке*, очень вряд ли пойдёт читать код *функции поиска предложений*.

Выход из этого логического тупика мы подробно разбирали в главах раздела «Обратная совместимость», посвящённых сильной и слабой связности. Единственный способ «перебросить мостик» между всеми контекстами, собранными в одном UI-компоненте — это декомпозировать компонент на несколько сущностей, каждая из которых отвечает за определённый уровень абстракции, и организовать взаимодействие между ними на принципах слабой связности.

Идея декомпозиции визуальных объектов, разумеется, придумана не нами и формализована во множестве методологий — в первую очередь, MV*-фреймворках (Model—View—Controller, Model—View—Presenter и т.д.) Все они, в конечно счёте, предлагают реализовать следующий подход:

  1. Выделить сущность *модель*, отвечающую только за данные, поверх которых построен компонент.
  2. Потребовать, чтобы внешний вид и поведение компонента полностью определялись его моделью.
  3. Построить механизм изменений внешнего вида компонента через изменение модели.

Разница между MV*-подходами заключается в разрешённых направлениях взаимодействия между составляющими.

(схемы MVC, MVP, MVVP)

MV*-подход выглядит вполне простым и понятным в случае статических объектов, но, увы, становится гораздо менее удобным в случае интерактивных, поскольку оставляет открытым вопрос о том, где и как должно храниться *состояние* компонента (например, «происходит ли сейчас анимация нажатия кнопки»). Фактически, это тоже часть данных, на которых строится компонент, но редко часть модели (в том числе потому, что это явное нарушение принципа изоляции уровней абстракции). Для компонентов, обладающих сложным (и асинхронно изменяемым) внутренним состоянием мы должны пойти ещё дальше, и декомпозировать также данные, поверх которых он строится. UI-компоненты, как правило, оперируют:

  * данными, полученными из внешних источников, и связанные с бизнес-логикой (в случае нашей кнопки — это предложение, которое по нажатию конвертируется в заказ);
  * данными, унаследованными по различным иерархиям (например, из визуальной иерархии кнопка получает положение своего контекста на экране);
  * данными, которые описывают её собственное внутреннее состояние (например, состояние анимации нажатия кнопки).

Если мы позволяем кастомизировать всё вышеперечисленное, кнопка превращается в очень сложный объект:

```
class Button extends SystemButton {
  // Модель данных
  public model: IButtonModel;
  // Состояние кнопки
  public state: IButtonState;
  // Отображение кнопки
  public view: IButtonView;
}
// Каждый из суб-компонентов
// должен в свою очередь 
// предоставлять функциональность:
interface IButtonModel {
  // доступа к данным
  data: IDataAccessor,
  // генерации событий изменения
  // данных
  events: IEventEmitter,
  // вышестоящий контекст
  parentContext: IContext
}
```

Напомним, префикс `I` мы используем, чтобы индицировать *интерфейсы* (абстрактные классы). В данном случае подразумевается, что кнопка должна уметь работать с любой моделью, состоянием и/или отображением, лишь бы они выполняли требуемый программный контракт. Именно благодаря этому требованию мы можем говорить о полной замене одного из компонентов кнопки альтернативной реализацией.

**NB**: чтобы замена компонента работала, должен существовать способ её осуществить — например, через функции-билдеры.

```
class Button {
  constructor() {
    this.view = this.buildView();
    …
  }
}
// Разработчик может переопрелить
// метод построения отображения
class MyButton {
  buildView() {
    return new MyCustomView();
  }
}
```

Чтобы вся эта система заработала, мы должны добавить к ней события: каждый из компонентов генерирует определённые события и обрабатывает события других компонентов. Например, реакцию на нажатие мы можем описать так:

```
button.events.on(
  // Получаем событие 
  // нажатия кнопки
  'press',
  (event) => {
    // Пытаемся заблокировать
    // кнопку, чтобы не допустить
    // отправки двух запросов 
    // на создание заказа
    button.state.lock().then(
      (lock) => {
        // В случае успеха
        // создаём заказ
        const order = await api
          .createOrder(
            button.data.offer
          );
        lock.release();
        this.events.emit(
          'orderCreated',
          order
        );
      },
      (error) => {
        // Если блокировку
        // не удалось получить,
        // как-то обработать
        // ошибку
        …
      }
    );
  }
);
```

В свою очередь, сущность view должен опираться на состояние кнопки и события её изменения:

```
class ButtonView {
  public parent: Button;

  protected initialize () {
    this.parent.state.events.on(
      'lock',
      () => {
        // Вносит изменения во
        // внешний вид кнопки
        …
      }
    );
    // аналогично для 'unlock'
    …
    // Объект view должен
    // генерировать событие 'press',
    // только если он не заблокирован
    this.element.onTouch(
      (event) => {
        if (!this.parent.state.locked) {
          this.events.emit('press');
        }
      }
    )
  }
}
```

Важно, что при этом каждая составляющая должна оперировать сущностями своей области ответственности, как показано в примере выше: объект View получает от системы событие о том, что над ним произошло касание пользователя, но превращает его в событие 'press' только если UI не заблокирован, таким образом выступая «фильтром», который переформулирует низкоуровневые системные события так, чтобы они стали *ближе* к бизнес-логике.

Заменив получение и генерацию событий в некоторых парах компонентов на вызовы методов родительского контекста, мы можем редуцировать систему до MV*- или, скажем, Redux-подобного фреймворка. В рамках MVC мы написали бы следующий код:

```
class ButtonView {
  protected model;
  protected controller;

  protected initialize () {
    this.element.onTouch(
      function (event) {
        this.controller.onPress();
      }
    )

    this.model.onChange(
      function () {
        // Перерисовывает кнопку
        // в соответствие с моделью
      }
    )
  }
}

class OrderButtonController () {
  protected writeableModel;

  public onPress () {
    this.writeableModel.set('locked', true);
    const order = await api
      .createOrder(
        this.model.offer
      );
    this.writeableModel.set('order', order);
    this.writeableModel.set('locked', false);
  }
}
```

Как можно заметить, получившийся код полностью эквивалентен предыдущему варианту с точностью до замены событий на вызовы функций. Это неслучайно — смысл MV*-фреймворков как раз заключается в том, чтобы интерфейсно *запретить* определённые направления распространения событий (скажем, только контроллер может изменять состояние модели), тем самым снизив общую сложность взаимодействия.