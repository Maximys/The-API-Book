### Декомпозиция UI-компонентов. MV*-подходы

Продолжим рассматривать пример с анимацией панели, и отметим неприятную проблему в нашем коде (для простоты опустим часть с получением доступа к разделяемому ресурсу):

```
searchBox.on('selectOffer', (offer) {
  searchBox.offerPanel.render(offer, {
    left: screenWidth
  });

  searchBox.state.
    isInnerAreaLocked = true;

  await searchBox.offerPanel
    .view.animate('left', 0, '1s');

  searchBox.state.
    isInnerAreaLocked = false;
});
```

В данном фрагменте кода налицо неполное разделение уровней абстракций и сильная связность: обработчик *логического* события `selectOffer`, сформулированного в терминах предметной области высокого уровня («выбрано предложение»), запускает такой *низкоуровневый* процесс как анимация. Практическое следствие этой проблемы следующее: если разработчик захочет изменить способ показа предложения (использовать какую-то другую сущность, не `offerPanel` или, скажем, заменить имплементацию `offerPanel` через, например, отрисовку анимации на уровне GL-контекста), этот код перестанет работать. Соответственно, если мы хотим включить вышеприведённое поведение (анимацию показа предложения по его выбору) как часть UX нашего компонента (т.е. сделать поведением по умолчанию), писать код в таком виде мы не можем. (Строго говоря, и часть про блокирование `innerArea` тоже может оказаться ненужной, если мы дадим возможность показывать предложение где-то в другой части экрана, но этот случай мы опустим).

Как мы описывали в главе «Слабая связность», чтобы избежать этих проблем, необходимо ввести промежуточные сущности между разноуровневыми контекстами и необязывающие взаимодействия между ними. В нашем случае, введём некоторый объект-арбитр, который перехватывает и переформулирует события:

```
class Arbiter implements IArbiter {
  constructor(
    searchBox: ISearchBox,
    offerPanel: IOfferPanel
  ) {
    // Панель показа предложений
    // должна быть каким-то образом
    // привязана к арбитру
    offerPanel.setArbiter(this);
    
    searchBox.on('selectOffer', (event) {
      // Арбитр переформулирует события
      // `searchBox` в требования к
      // панели предложений.

      // 1. Необходимо задать контент панели
      this.emit(
        'setContent',
        // Какая-то, возможно переопределяемая
        // функция получения визуального
        // контента панели по offer-у
        this.generateContent(offer.event)
      );
      // 2. Необходимо инициализировать
      // положение панели
      this.emit(
        'setInitialPosition',
        // Мы только указываем панели,
        // что она должна быть в состоянии
        // «не видна», не предписывая
        // конкретной механики скрытия
        { "state": "hidden" }
      );
      // 3. Необходимо оповестить сам SearchBox
      // о том, что `innerArea` заблокирована
      this.emit('innerAreaLocked');
      // 4. Сообщаем панели, что необходимо
      // анимировать показ контента
      this.emit(
        'animateContentShow',
        // Желаемая длительность анимации
        {'duration': '1s'}
      );
      // 5. Как только контент панели
      // полностью готов и показан,
      // разблокировать `innerArea`
      offerPanel.on('contentReady', () => {
        this.emit('innerAreaUnlocked')
      })
    });
  }
}
```

Важно, что интерфейсы `ISearchBox` и `IContentPanel` (как и интерфейс IArbiter) состоят *только* из событий (плюс метод связывания всех трёх сущностей, в нашем случае — `IContentPanel.setArbiter`) и, таким образом, не являются обязывающими для всех трёх сторон. Панель предложений может быть заменена на реализацию, которая вообще не поддерживает никаких анимаций и просто сразу генерирует сообщение `contentReady` после получения `setContent` и отрисовки переданного контента.

Аналогичным образом, через подобные арбитры, мы можем выстроить взаимодействие между любыми составляющими визуального компонента, где нам требуется «перебросить мостик» через уровни абстракций — но, разумеется, это *чрезвычайно* дорого в имплементации. Чем больше у нас таких суб-компонентов, чем дальше логическая дистанция между их предметными областями — тем больше арбитров, событий и возможностей сделать ошибку в дизайне.

Вновь обратимся к главе «Слабая связность»: мы могли бы упростить взаимодействие и снизить сложность коде, если бы разрешили нижележащим субкомпонентам напрямую вызывать методы вышестоящих сущностей. Например, так:

```
searchBox.on('selectOffer', (event) {
  this.emit(
    'setContent',
    this.generateContent(offer.event)
  );
  // Вместо бросания события,
  // напрямую модифицируем состояние
  // родительского компонента
  searchBox.lockInnerArea();
  …
}
```

Сделав подобное упрощение, мы фактически получили компонент, следующий методологии [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller): `OfferPanel` — это view, который непосредственно взаимодействует с пользователем и оповещает об этом событиями, `Arbiter` — это controller, который получает события от view и модифицирует модель (сам `SearchBox`). Если мы выберем другие направления редукции полного взаимодействия, мы получим другие варианты MV*-фреймворков (Model—View—View model, Model—View—Presenter и т.д.) Все они, в конечно счёте, предлагают реализовать следующий подход:

  1. Выделить сущность *модель*, отвечающую за данные, поверх которых построен компонент.
  2. Потребовать, чтобы внешний вид и поведение компонента полностью определялись его моделью.
  3. Построить механизм изменений внешнего вида компонента через изменение модели.
  4. Запретить взаимодействия, которые не соответствуют выбранному способу разделения компонента (например, в MVC view запрещено изменять состояние модели напрямую).

(схемы MVC, MVP, MVVP)

Достоинством MV*-подходов и иных способов ограничения сложности субкомпонентного взаимодействия (например, Redux также является одним из подходов, хотя он оставляет реализацию view за скобками) является строгое насаждение уровней абстракции, которое упрощает дизайн API и вообще оставляет меньше возможностей сделать в нём ошибку. Один очевидный недостаток всех этих фреймворков — это фиксация явных интерфейсов (в нашем случае — контроллер напрямую вызывает методы `SearchBox`-а), что означает ограничение возможности замены составляющих на альтернативные имплементации. Вторую очевидный недостаток мы рассмотрим ниже.

#### Паттерн «модель»

Общая черта, объединяющая все MV*-фреймворки — это выделение сущности «модель» (некоторого набора данных), которая детерминировано *определяет* внешний вид и состояние UI-компонента. Изменения в модели порождают и изменения в отображении компонента (или дерева компонентов; модель может быть одной на всё приложение, и полностью определять весь интерфейс).

У этого подхода есть несколько очень важных свойств:
  * он позволяет восстанавливать состояние в случае ошибок (например, сбоя в рендеринге или перезагрузки приложения);
  * любые переходы между состояниями можно рассматривать как применение изменения (патча) к модели, что, помимо прочего, позволят «возвращаться в прошлое», т.е. отменять последние действия.

Один из частных случаев использование модели — это сериализация её в виде URL (или App Links в случае мобильных приложений). Тогда URL полностью определяет состояние приложения, и любые изменения состояния отражаются в виде изменений URL. Этот подход чрезвычайно удобен тем, что можно сгенерировать специальные ссылки, открывающие нужный экран в приложении.

Недостатки этого подхода, увы, также очевидны:
  * если задаться целью *полностью* описать состояние компонента, то мы обязаны внести в него и такие данные, как выполняющиеся сейчас анимации и даже процент их выполнения — очевидно, на таком уровне детализации ни о каком хранении модели в виде набора патчей речи идти не может, так как нам придётся сохранить каждый шаг анимации;
  * таким образом, модель обязана будет содержать в себе все данные всех уровней абстракции (причём, зачастую, дублирующие друг друга — например, контент панели предложения является производной от показанного предложения), и, более того, каким-то образом включать в себя две или более иерархии подчинения (по семантической и визуальной иерархиям, а так же, возможно, все селекторы и правила, как мы описали их в главе «Вычисляемые свойства»).

В нашем примере с анимацией панели предложения из предыдущей главы мы должны составить полную модель в таком виде:

```
{
  "searchBox": {
    "isInnerAreaLocked": true,
    "offerPanel": {
      "content",
      "animations": [{
        "left": {
          "begin": "100%",
          "end": "0",
          "progress": 0.23
        }]
      }
    },
    …
  }
}
```

Подобная полная модель представляет собой проблему не только теоретически и семантически (перемешивание в одной сущности разнородных данных), но и в практическом смысле — сериализация таких моделей окажется ограничена рамками конкретной версии API или приложения. Если мы в следующей версии изменим анимацию (панель станет выезжать справа), то старые ссылки перестанут работать (либо нам потребуется держать слой совместимости, описывающий, как интерпретировать модели предыдущих версий).

В практическом смысле, разумеется, разработчики визуальных SDK и не пытаются строить такие огромные модели, описывающие до последней запятой состояние каждого субкомпонента в дереве; модели состоят из *важных* полей, а всё «неважное» остаётся на откуп другим частям системы. (Что, по факту, означает следующее: UI-библиотеки никогда не реализуют MV*-подходы *строго*, поскольку это попросту невозможно. View-компоненты всегда имеют свои скрытые состояния-субмодели, которые лишь частично согласованы с основной моделью — в том числе потому, что далеко не всегда возможно это согласование произвести синхронно.)