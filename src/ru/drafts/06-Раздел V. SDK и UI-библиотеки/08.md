### Backend-Driven UI

Другой способ обойти сложность «переброса мостов» между несколькими предметными областями, которые нам приходится сводить в рамках одного UI-компонента — это убрать одну из них. Как правило, речь идёт о бизнес-логике: мы можем разработать компоненты полностью абстрактными, и скрыть все трансляции UI-событий в полезные действия вне контроля разработчика.

В такой парадигме код открытия панели предложений (которая должна перестать быть панелью предложений и стать просто «панелью чего-то») выглядел бы так:

```
searchBox.on('selectItem', (item) => {
  this.isInnerAreaLocked = true;
  this.innerAreaContent = await api
    .getInnerAreaContent(
      this.model, item
    );
  this.isInnerAreaLocked = false;
});
```

Или даже так:

```
searchBox.on('selectItem', (item) => {
  // Получаем от сервера набор
  // команд, которые необходимо выполнить
  // по событию selectItem
  const reaction = await api.onSelectItem(
    this.model, this.state, item
  );
  this.exec(reaction);
});
```

(Реализацией этой идеи можно также считать «Web 1.0» — сервер присылает готовый контент страницы, а вся интерактивность сводится к переходам по ссылкам.)

Этот подход, безусловно, является крайне привлекательным с двух сторон:
  * возможность с сервера регулировать поведение клиента, в том числе устранять возможные ошибки в реальном времени;
  * возможность сэкономить на разработке консистентной и читабельной номенклатуре сущностей публичного SDK, ограничившись минимальным набором доступной функциональности.

Тем не менее, мы не можем не отметить: при том, что любая крупная IT-компания проходит через эту фазу — разработки Backend-Driven UI (они же — «тонкие клиенты») для своих приложений или своих публичных SDK — мы не знаем ни одного заметного на рынке API, разработанного в этой парадигме (кроме протоколов удалённых терминалов), хотя во многих случаях возникающими сетевыми задержками вполне можно было бы пренебречь. Нам сложно выделить конкретные причины, почему так происходит, но мы рискнём предположить, что разработать серверный код управления UI ничуть не проще, нежели клиентский — даже если вы не должны документировать каждый метод и абстрагировать каждую сущность — и игра, в конечном счёте, не стоит свеч.