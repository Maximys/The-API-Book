### Семантика протокола HTTP

Итак, после трёх вступительных глав с прояснением основных терминов и понятий (такова, увы, цена популярности технологии) мы перейдём, наконец, непосредственно к вопросам дизайна HTTP API.

В описании семантики и формата протокола мы будем руководствоваться свежевышедшим [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html), который заменил аж девять предыдущих RFC, описывавших разные аспекты технологии (правда, большое количество различной дополнительной функциональсти всё ещё покрывается отдельными стандартами, например, метод `PATCH` так и не вошёл в основной стандарт и всё ещё регулируется [RFC 5789](https://www.rfc-editor.org/rfc/rfc5789)).

HTTP-запрос представляет собой применение определённого глагола к URL с указанием версии протокола и передачей дополнительной мета-информации в заголовках и, возможно, каких-то данных в теле запроса:

```
POST /v1/orders HTTP/2.0
Host: our-api-host.tld
Content-Type: application/json

{
  "coffee_machine_id": 123,
  "currency_code": "MNT",
  "price": "10.23",
  "recipe": "lungo",
  "offer_id": 321,
  "volume": "800ml"
}
```

Ответом на HTTP-запрос будет являться конструкция, состоящая из статус-кода ответа, сообщения, заголовков и, возможно, тела ответа.

```
201 Created
Location: /v1/orders/123
Content-Type: application/json

{
  "id": 123
}
```

#### Важное замечание о консистентности

Один и тот же параметр в разных ситуациях может находиться в разных частях запроса. Скажем, идентификатор партнёра, совершающего запрос, может быть передан:
  * в имени поддомена `<partner-id>.domain.tld`;
  * как часть пути `/v1/<partner-id>/orders`;
  * как query-параметр `/v1/orders?partner_id=<partner-id>`;
  * как заголовок

      ```
      GET /v1/orders
      X-ApiName-Partner-Id: <partner-id>
      ```

  * как поле в теле запроса

      ```
      POST /v1/orders/retrieve
      {
        "partner_id": <partner-id>
      }
      ```

Возможны и более экзотические варианты: размещение параметра в схеме запроса или `Content-Type` ответа.

Однако при перемещении параметра между различными составляющими запроса мы столкнёмся с тремя неприятными явлениями:
  * некоторые виды параметров чувствительны к регистру (путь, query-параметры, имена полей в JSON), некоторые нет (домен, имена заголовков);
      * при этом со *значениями* заголовков и вовсе неразбериха: часть из них по стандарту обязательно нечувствительна к регистру (в частности, `Content-Type`), а часть, напротив, обязательно чувствительна (например, `ETag`);
  * наборы допустимых символов и правила экранирования также различны для разных частей запроса
      * для path, например, стандарта экранирования символов `/`, `?` и `#` нет совсем;
  * для разных частей запросов используется разный кейсинг:
      
      * `kebab-case` для домена, заголовков и пути;
      * `snake_case` для query-параметров;
      * `snake_case` или `camelCase` для тела запроса;

      При этом использование и `snake_case`, и `camelCase` для доменного имени невозможно, знак подчеркивания в доменных именах недопустим, а заглавные буквы будут приведены к строчным.

Чисто теоретически возможно использование `kebab-case` во всех случаях, но в большинстве языков программирования имена переменных в `kebab-case` недопустимы, что приведёт к неудобству работы с таким API.

Короче говоря, ситуация с кейсингом настолько плоха и запутанна, что консистентного и удобного решения попросту нет. В этой книге мы придерживаемся следующего правила: токены даются в том кейсинге, который является общепринятым для той секции запроса, в которой находится токен; если положение токена меняется, то меняется и кейсинг. (Мы далеки от того, чтобы рекомендовать этот подход всюду; наша общая рекомендация, скорее — не умножать энтропию и пытаться минимизировать такого рода коллизии.)

**NB**. Вообще говоря, JSON исходно — это JavaScript Object Notation, а в языке JavaScript кейсинг по умолчанию - `camelCase`. Мы, тем не менее, позволим себе утверждать, что JSON уже перестал быть форматом данных, привязанным к JavaScript, и давно используется для организации взаимодействия агентов, реализованных на любых языках программирования. Использование `snake_case` по крайней мере позволяет легко перебрасывать параметр из query в тело и обратно, что, обычно, является наиболее частотным кейсом при разработке HTTP API.