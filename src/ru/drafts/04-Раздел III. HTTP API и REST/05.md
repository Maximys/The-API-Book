### Принципы организации HTTP API

Перейдём теперь к конкретике: как разрабатывать HTTP API так, чтобы извлекать выгоду из следования протоколу. Представим себе обычную операцию получения последних заказов пользователя. Например, мы можем поступить следующим образом:

```
GET /orders
Authorization: Bearer <token>
```

Получив такой запрос, сервер проверит валидность токена, получит идентификатор пользователя `user_id`, обратится к базе данных и вернёт отсортированный по времени создания список заказов.

Пока вопросы производительности нас не волнуют, подобная схема прекрасно работает. Однако, с ростом количества пользователей, мы рано или поздно столкнёмся с тем, что подобная монолитная архитектура нам слишком дорого обходится, и принимаем решение декомпозировать единый бэкенд на четыре микросервиса:
  * сервис A, проверяющий авторизационные токены;
  * сервис B, хранящий текущие заказы пользователя;
  * сервис C, хранящий завершённые заказы пользователя;
  * сервис-гейтвей D, который маршрутизирует запросы между другими микросервисами.

Таким образом, запрос будет проходить по следующему пути:
  * гейтвей D получит запрос и отправит его в сервисы B и C;
  * сервисы B и C обратятся к сервису A, проверят токен, и вернут данные по запросу;
  * сервис D скомбинирует ответы сервисов B и C и вернёт их пользователю.

Нетрудно заметить, что мы тем самым создаём нагрузку на сервис A: теперь к нему обращается каждый из вложенных микросервисов, поскольку самостоятельно выяснить идентификатор пользователя они не могут. Каким образом мы можем решить проблему? Очевидно, сделав так, чтобы `user_id` уже был включён в запрос:
  * гейтвей D получает запрос и через сервис A меняет токен на `user_id`
  * гейтвей D обращается к сервису B
      ```
      GET /ongoing-orders
      X-OurApi-User-Id: <user id>
      ```
      и к сервису C
      ```
      GET /finished-orders
      X-OurApi-User-Id: <user id>
      ```

**NB**: альтернативно мы могли бы закодировать имя пользователя в самом токене согласно, например, [стандарту JWT](https://www.rfc-editor.org/rfc/rfc7519).

Теперь сервисы B и C получают запрос в таком виде, что им не требуется выполнение дополнительных действий (идентификация пользователя через сервис А) для получения результата. Тем самым мы переформулировали запрос так, что он сформулирован в терминах предметной области сервиса (в данном случае — сервис истории заказов естественным образом хранит идентификатор пользователя как неизменяемый параметр заказа), а не клиента, осуществляющего вызов. Этот принцип скрывается под буквой S в аббревиатура REST: «stateless».

Пойдём теперь чуть дальше и подметим, что список завершённых заказов пользователя меняется очень редко. Нет никакой нужды каждый раз получать его заново — мы могли бы закэшировать его на стороне гейтвея D. Для этого нам нужно сформировать ключ кэша, которым фактически является идентификатор клиента. Мы можем пойти длинным путём:
  * перед обращением в сервис C составить ключ и обратиться к кэшу;
  * если данные имеются в кэше, ответить клиенту из кэша; иначе обратиться к сервису C и сохранить полученные данные в кэш.

А можем срезать пару углов: если мы добавим идентификатор пользователя непосредственно в запрос, то можем положиться на HTTP-кэширование, которое наверняка или реализовано в нашем фреймворке, или добавляется в качестве плагина за пять минут. Тогда гейтвей D, получив запрос `GET /orders`, обратится к ресурсу `service-c.tld/<user-id>/finished-orders` и получит данные либо из кэша, либо непосредственно из сервиса.

