### Атомарность

Вернёмся теперь от webhook-ов обратно к разработке API прямого вызова. Дизайн эндпойнта `orders/bulk-status-change`, описанный в предыдущей главе, ставит перед нами интересный вопрос: что делать, если наш бэкенд часть изменений смог обработать, а часть — нет? 

Правило по умолчанию очень простое: если вы можете обеспечить атомарность, т.е. выполнить либо все изменения сразу, либо ни одно из них — сделайте это.

**Плохо**:
```
// Партнёр уведомляет нас об
// изменениях статуса
POST /v1/orders/bulk-status-change
{
  "status_changes": [{
    "order_id": "1",
    "new_status": "accepted",
    // Иная релевантная информация,
    // например, время готовности
    …
  }, {
    "order_id": "2",
    "new_status": "rejected",
    "reason"
  }]
}
→
500 Internal Server Error
```
```
// Партнёр вычитывает список заказов
GET /v1/orders/last?limit=2
→
{
  "orders": [{
    // Статус заказа с id="1" 
    // не изменился
    "order_id": "1",
    "status": "new"
  }, {
    // Но статус заказа id="2" 
    // был успешно изменён
    "order_id": "2",
    "status": "rejected"
  }],
  "cursor"
}
```

Почему это плохо: партнёр никак не может узнать, что операция, которую он посчитал ошибочной, на самом деле частично применена. Для этого нужно разрабатывать сложную систему синхронизации, которая после получения ошибок будет пытаться восстановить состояние всех заказов.

Если способа обеспечить атомарность выполнения операции нет, следует очень хорошо подумать над её обработкой. Следует предоставить способ получения статуса каждого изменения отдельно.

**Лучше**:
```
// Партнёр уведомляет нас об
// изменениях статуса
POST /v1/orders/bulk-status-change
{
  "status_changes": [{
    "order_id": "1",
    "new_status": "accepted",
    // Иная релевантная информация,
    // например, время готовности
    …
  }, {
    "order_id": "2",
    "new_status": "rejected",
    "reason"
  }]
}
→
// Можно воспользоваться статусом
// «частичного успеха», 
// если он предусмотрен протоколом
→
{
  "changes": [{
    "change_id",
    "occurred_at",
    "order_id": "1",
    "operation_status": "success"
  }, {
    "change_id",
    "occurred_at",
    "order_id": "2",
    "operation_status": "fail",
    "error"
  }]
}
```

Здесь:
  * `change_id` — уникальный идентификатор каждого атомарного изменения;
  * `occurred_at` — время проведения каждого изменения;
  * `error` — информация по ошибке для каждого изменения, если она возникла.

Однако внимательный читатель может подметить, что это решение лишь уменьшает вероятность возникновения ситуации неопределённости для партнёра, но не снимает проблемы восстановления состояния после сбоя — так как сбой может произойти на сетевом уровне (или же в коде нашего эндпойнта может произойти настолько критическая ошибка, что мы не сможем сформировать ответ с разбивкой успех/неуспех). Поэтому массовые неатомарные операции должны сопровождаться эндпойнтом для восстановления состояния (возможно также серверными нотификациями)

```
GET /v1/order-status-changes/history⮠
  limit=2
→
{
  "order_status_changes": [{
    "change_id",
    "occurred_at",
    "order_id": "1",
    "operation_status": "success"
  }, {
    "change_id",
    "occurred_at",
    "order_id": "2",
    "operation_status": "fail",
    "error"
  }],
  "cursor"
}
```

Неатомарные изменения нежелательны ещё и потому, что вносят неопределённость в понятие идемпотентности, даже если каждое вложенное изменение идемпотентно. Рассмотрим такой пример:

```
// Партнёр уведомляет нас об
// изменениях статуса
POST /v1/orders/bulk-status-change
X-Idempotency-Token: <токен>
{
  "status_changes": [{
    "order_id": "1",
    "new_status": "accepted",
    …
  }, {
    "order_id": "2",
    "new_status": "rejected",
    …
  }]
}
→
{
  "changes": [{
    "order_id": "1",
    "operation_status": "success"
    …
  }, {
    "order_id": "2",
    "operation_status": "fail",
    "error"
  }]
}

```

Допустим, клиент не смог получить наш частично-успешный ответ и повторил запрос с тем же токеном идемпотентности.

```
// Партнёр повторно
// уведомляет нас об
// изменениях статуса
POST /v1/orders/bulk-status-change
X-Idempotency-Token: <токен>
{
  "status_changes": [{
    "order_id": "1",
    "new_status": "accepted",
  }, {
    "order_id": "2",
    "new_status": "rejected",
    "reason"
  }]
}
→
{
  "changes": [{
    "order_id": "1",
    "operation_status": "success"
    …
  }, {
    "order_id": "2",
    "operation_status": "success",
  }]
}
```

По сути, для клиента всё произошло ожидаемым образом: изменения были внесены, и последний полученный ответ корректен. Однако по сути состояние ресурса после первого запроса отличалось от состояния ресурса после второго запроса, что противоречит самому определению идемпотентности.

Более корректно было бы при получении повторного запроса с тем же токеном ничего не делать и возвращать ту же разбивку ошибок, что была дана на первый запрос — для чего нам вновь необходимо хранение истории изменений.

На всякий случай уточним, что вложенные операции должны быть сами по себе идемпотентны. Если же это не так, то следует каким-то детерминированным образом сгенерировать внутренние ключи идемпотентности на каждую вложенную операцию в отдельности (в простейшем случае — считать токен идемпотентности внутренних запросов равным токену идемпотентости внешнего запроса, если это допустимо в рамках предметной области; иначе придётся использовать составные токены — в нашем случае, например, в виде `<order_id>:<external_token>`).
