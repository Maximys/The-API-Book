### Технические способы борьбы с несанкционированным доступом к API

Реализация парадигмы, описанной в предыдущей главе — централизованной борьбы с фродом, осуществляемым через клиентские API партнёра — на практике сталкивается с достаточно нетривиальными проблемами. Допустим, с помощью каких-то признаков и/или поведенческого анализа мы определили, что запрос с большой вероятностью выполнен не реальным человеком, а роботом. Что мы можем с этим сделать?

В случае сервисов для конечных пользователей мы могли бы показать капчу; но в случае API это весьма проблематично, особенно если вы пренебрегли советом [«Предусмотрите ограничения»](#chapter-11-paragraph-19). Если полная отработка сценария (идентификация пользователя — показ капчи или honeypot-а — пометка результатов прохождения теста) на вашем уровне невозможна или не была предусмотрена, вам придётся переложить её на партнёра (т.е. это партнёр должен будет показывать капчу и идентифицировать пользователя, основываясь на сигналах, поступающих от эндпойнтов API) что, конечно, сильно снижает комфортность работы с таким API.

Другой способ борьбы с роботами — это попытка идентифицировать среду атаки. Программная оболочка, через которую выполняются запросы, не идентична реальному пользовательскому устройству, и этот факт можно попытаться определить — особенно это касается веб-страниц, которые часто обрабатываются не эмулятором браузера, а каким-то фреймворком, который будет не способен, например, исполнять JavaScript или не поддерживает последние дополнения к WebAPI браузеров.

Немаловажен и вопрос, а что вы будете делать, если вы всё же смогли идентифицировать злонамеренного пользователя, но не можете сделать так, чтобы он прекратил слать запросы. В какой-то момент придётся прибегнуть к одной из двух стратегий:
  * бан пользователя по ip (подсети, автономной системе), Referer-у или идентификатору приложения (если они передаются), либо какому-то частному правилу (например, по заголовку User-Agent, если злоумышленник забыл его подменить);
  * отдача ложного ответа.

С точки зрения эффективности противоборства атаке второй вариант куда предпочтительнее, поскольку перекидывает мяч на ту сторону: теперь уже злоумышленнику нужно каким-то образом определять, был ли он пойман. Но с точки зрения морали (и буквы закона) этот способ весьма сомнителен — особенно если учесть, что всегда возможны ложположительные срабатывания, и некорректные данные будут отданы честному пользователю.

#### Противодействие краже ключей

Рассмотрим теперь второй вариант несанкционированного использования, когда злоумышленник крадёт API-ключ добросовестного партнёра и вставляет его в своё приложение. Запросы при этом генерируются настоящими пользователями, а значит капча никак не поможет — но помогут другие методы.

  1. Вести иерархическую статистику доступа по сетям, как было рекомендовано в предыдущей главе. Если приложение злоумышленника всё-таки не обычное приложение для честных потребителей, а какой-то закрытый сервис для ограниченного круга пользователей, этот факт будет виден по аномальной плотности запросов с определённых ip / подсетей / автономных систем (а если повезёт — то ещё и по подозрительным referer-ам, которые закрыты для внешнего доступа).

  2. Дать возможность партнёрам ограничивать функциональность, которая доступна по ключу:
      * устанавливать диапазон допустимых IP-адресов для серверных API, идентификаторов приложений и хостов в клиентских API;
      * разрешать использование конкретного ключа только для конкретных методов API;
      * вводить иные разумные ограничения (например, для ключа нашего кофейного API можно установить ограничения по странам и городам, в которых работает партнёр).

  3. Вводить дополнительное подписывание запроса:
      * например, если на странице вебсайта партнера осуществляется поиск лучших предложений лунго, для чего клиент обращается к URL вида `/v1/search?recipe=lungo&api_key={apiKey}`. В этом случае API-ключ может быть заменён на сгенерированную сервером подпись вида `sign = HMAC("recipe=lungo", apiKey)`. Такая подпись может быть украдена, но будет бесполезна для злоумышленника, так как позволяет найти только лунго;
      * вместо API-ключа можно использовать одноразовые пароли (Time-Based One-Time Password, TOTP); такие токены действительны, как правило, в течение короткого времени, порядка минуты, что чрезвычайно затрудняет злоумышленнику работу с украденными ключами.
  
  4. Банить ключи. Эта операция почти всегда вызовет негативную реакцию партнёра, но, в конце концов, для многих бизнесов лучше временно лишиться какой-то функциональности в приложении, чем получить многомиллионный счёт.

#### Щит и меч
    
Описанные выше методы — по сути, вариации существующих алгоритмов защиты авторских прав (DRM, Digital Rights Management), поскольку конечная цель защиты та же: не допустить несанкционированного использования данных, доступных клиенту. И, как и в случае DRM, недостаток этого подхода — это усложнение использования сервиса для абсолютно законопослушных партнёров и конечных пользователей. Это первая причина, по которой совершенствование и усложнение защиты может привести к неконкурентоспособности продукта и накоплению негативной репутации в глазах потребителей. 

Вторая причина состоит в том, что любые технологии подобного рода — всегда эвристические и не дают стопроцентных гарантий. По большому счёту их цель — сделать атаку на API настолько затратной, чтобы пропала целесообразность атаковать. Предотвратить атаку полностью невозможно, поскольку у злоумышленника всегда есть в запасе дорогой, но работающий способ посадить реальных людей с реальными приложениями, чтобы они выполняли нужные запросы к API и были неотличимы от обычных пользователей. Вводя сложные алгоритмы, вы тем самым проводите своеобразный «эволюционный отбор», направленный на выявление самых умных и хитрых злоумышленников, противодействовать которым будет гораздо сложнее, чем наивным попыткам украсть ключи.

В конечном итоге, когда наивные злоумышленники закончились, а умные научились обходить все технические препоны, бороться с выявленным нарушением вам придётся административными методами, т.е. путём написания жалоб хостерам «пиратских» сайтов и обращений в магазины приложений и в суд. Для этого важно, чтобы доказательства нарушения были просты и очевидны, в то время как продемонстрировать факт взлома сложных DRM-алгоритмов может быть далеко не тривиальной задачей. С нашей точки зрения лучшей политикой борьбы с фродом является пассивный мониторинг нарушений (с последующим принятием административных мер) плюс возможность партнерам по их желанию установить дополнительные технические ограничения плюс административное преследование наиболее вопиющих случаев. (Уточнение «вопиющих» важное: судебные действия против таких «предпринимателей» обязательно вызовут напряженность со стороны бизнеса и разработчиков, которые могут иметь совсем другое мнение относительно тяжести нарушения; важно, чтобы деяние заслуживало строгости наказания и в глазах незаинтересованных сторон.)
