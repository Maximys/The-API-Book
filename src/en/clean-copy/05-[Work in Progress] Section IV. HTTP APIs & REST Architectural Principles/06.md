### [Designing a Nomenclature of URLs and Applicable Operations][http-api-urls-crud]

As we noted on several occasions in the previous chapters, neither the HTTP and URL standards nor REST architectural principles prescribe concrete semantics to meaningful parts of a URL (notably, path fragments and key-value pairs in query). **The rules of organizing URLs in an HTTP API exist *only* for improving API's readability and consistency from the developers' perspective**. However, this doesn't mean they are not important. Quite the opposite: URLs in HTTP APIs are meanings of describing abstraction levels and entities' responsibility areas. Fine API hierarchy design must be reflected in a fine URL nomenclature design.

**NB**: the lack of specific guidance from the specification editors naturally led to inventing it by developers themselves. Many of these spontaneous practices that can be found on the Internet, such as the requirement to use only nouns in URLs, are claimed to be set in the standards or REST architectural principles (which they are not). Nevertheless, deliberately ignoring such self-proclaimed “best practices” isn't the best approach for an API vendor as it increases the chances to be misunderstood.

Traditionally, the following semantics is considered to be the default one:
  * Path components (i.e., fragments between `/` symbols) are used to organize nested resources, such as `/partner/{id}/coffee-machines/{id}`. A path might be extended further by adding new suffixes indicated subordinate sub-resources.
  * Query parameters are used to indicate non-strict connections (i.e., “many-to-many” relations such as `/recipes/?partner=<partner_id>`) or as a meaning to pass operation parameters (`/search/?recipe=lungo`).

This convention allows for decently reflecting almost any API's entity nomenclature and it is more than reasonable to follow it (and it's unreasonable to defiantly neglect it). However, this indistinctly defined logic inevitably leads to numerous variants of reading it:
  
  1. How exactly should the endpoints connecting two entities lacking clear relation between them be organized? For example, how should a URL for preparing a lungo on a specific coffee machine look like?
      * `/coffee-machines/{id}/recipes/lungo/prepare`
      * `/recipes/lungo/coffee-machines/{id}/prepare`
      * `/coffee-machines/{id}/prepare?recipe=lungo`
      * `/recipes/lungo/prepare?coffee_machine_id=<id>`
      * `/prepare?coffee_machine_id=<id>&recipe=lungo`
      * `/action=prepare&coffee_machine_id=<id>&recipe=lungo`

      All these options are semantically viable and are generally speaking equitable.

  2. How strictly should the literal interpretation of the `VERB /resource` construct be enforced? If we agree to follow the “only nouns in the URLs” rule (quite logically, a verb cannot be applied to a verb, right?) then we should use `preparer` or `preparator` in the examples above (and the `/action=prepare&coffee_machine_id=<id>&recipe=lungo` is unacceptable at all as there is no object to act upon). This, however, adds a visual noise in the form of “ator” suffixes but definitely doesn't make code more laconic or readable.

  3. If the call signature implies that the operation is by default unsafe or non-idempotent, does it mean that the operation *must* be unsafe or non-idempotent? As HTTP verbs bear double semantics (the meaning of the operation vs. possible side effects), it implies the ambiguity in organizing APIs. Let's consider the `/v1/search` resource from from our study API. With which verb should it be requested?
      * On one hand, `GET /v1/search?query=<search query>` explicitly declares there is no side effects (no state is overwritten) and the results can be cached (given all significant parameters are passed as parts of the URL).
      * On the other hand, a response to a `GET /v1/search` request must contain *a representation of the `/search` resource*. Are search results a representation of a search engine? The meaning of a “search” operation is much better described as “processing the representation enclosed in the request according to the resource's own specific semantics,” which is exactly the definition of the `POST` method. Additionally, how could we cache search requests? The results page is formed dynamically from a plethora of various sources, and the subsequent request with the same query might emit a different result.

      In other words, with any operation that runs an algorithm rather than returns a predefined result (such as listing offers relevant to a search phrase), we will have to decide what to choose: following verb semantics or indicating side effects? Caching results or hint the operation is not returning some stable dataset?