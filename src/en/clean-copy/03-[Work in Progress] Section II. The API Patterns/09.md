### [Atomicity of Bulk Changes][api-patterns-atomicity]

Let's return from *webhooks* back to developing direct-call APIs. The `orders/bulk-status-change` endpoint design, described in the previous chapter, raises an interesting question: what should we do if some changes were successfully processed by our backend and some were not?

Let's imagine the partner notifies us about status changes that happened with two orders:

```
POST /v1/orders/bulk-status-change
{
  "status_changes": [{
    "order_id": "1",
    "new_status": "accepted",
    // Other relevant data,
    // let's say, estimated
    // preparation time
    …
  }, {
    "order_id": "2",
    "new_status": "rejected",
    "reason"
  }]
}
→
500 Internal Server Error
```

The question is how to organize this “umbrella” endpoint (which is in fact a proxy to process a list of nested sub-requests) if changing one of the two orders emits an error. We might propose at least four different options:
  * A. Guarantee atomicity and idempotency. If any of the sub-requests is unsuccessful, other changes are not applied as well.
  * B. Guarantee idempotency but not atomicity. If some sub-requests fail, repeating the call with the same idempotency key results in no action and leaves the system exactly in the same state (i.e., the unsuccessful calls will never be carried out, even if all the obstacles were removed, until a new call with a new idempotency key is performed).
  * C. Guarantee neither idempotency nor atomicity and process the sub-requests fully independently.
  * D. Do not guarantee atomicity and forbid retries completely by requiring passing the actual resource revision (see the “[Synchronization Strategies](#api-patterns-sync-strategies)” chapter).

From general considerations, it looks like the first option suits public APIs best: if you can guarantee atomicity (which might be challenging from the scalability point of view), do it. In the first revision of this book, we recommended sticking to this solution unconditionally.

However, if we take a look at the situation from the partner's perspective, we learn it is not as straightforward as one might decide at first glance. Let us imagine that the partner implemented the following functionality:
  1. Partner's backend processes notifications about incoming orders through a *webhook*.
  2. The backend makes inquiries to coffee shops whether they are ready to fulfill the orders.
  3. Periodically, let's say once every 10 seconds, the partner collects all the status changes (i.e., all responses from the coffee shops) and calls the `bulk-status-change` endpoint with the list of the changes.

Imagine that in the third step, the partner got an error from the API endpoint. What would developers do about it? Most probably, one of the following solutions might be realized in the partner's code:

  1. Unconditional retry of the request: