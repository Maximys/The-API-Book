### [Decomposing UI Components][sdk-decomposing]

Let's transit to a more substantive conversation and try to understand, why the requirement to allow replacing component's subsystems with alternative implementations leads to dramatic interface inflation. We continue studying the `SearchBox` component from the previous chapter. Let us remind the reader the factors that complicate designing APIs for visual components:
  * Coupling heterogeneous functionality (such as business logic, appearance styling, and behavior) in one entity
  * Introducing shared resources, i.e. an object state that could be simultaneously modified by different actors (including the end-user)
  * Emerging of ambivalent hierarchies of inheritance of entity's properties and options.

We will make a task more specific. Imagine we need to develop a `SearchBox` that allows for the following modifications:
  1. Replacing the textual paragraphs representing an offer with a map with markers that could be highlighted:
      * Illustrates the problem of replacing a subcomponent (the offer list) while preserving behavior and design of other parts of the system; also, the complexity of implementing shared states.

      [![APP](/img/mockups/05.png "Search results on a map")]()

  2. Combining short and full descriptions of an offer in a single UI (a list item could be expanded, and the order can be created in-place):
      * Illustrates the problem of fully removing a subcomponent and transferring its business logic to other parts of the system.

      [![APP](/img/mockups/06.png "A list of offers with short descriptions")]()

      [![APP](/img/mockups/07.png "A list of offers with some of them expanded")]()

  3. Manipulating the data presented to the user and the available actions for an offer through adding new buttons, such as “Previous offer,” “Next offer,” and “Make a call.”

      [![APP](/img/mockups/08.png "An offer panel with additional icons and buttons")]()
  
      In this scenario, we're evaluating different chains of propagating data and options down to the offer panel and building dynamic UIs on top of it:

      * Some data fields (such as logo and phone number) are properties of a real object received in the search API response.

      * Some data fields make sense only in the context of this specific UI and reflect its design principles (for instance, the “Previous” and “Next” buttons).

      * Some data fields (such as the icons of the “Not now” and “Make a call” buttons) are bound to the button type (i.e., the business logic it provides).

The obvious approach to tackle these scenarios appears to be creating two additional subcomponents responsible for presenting a list of offers and the details of the specific offer. Let's name them `OfferList` and `OfferPanel` respectively.

[![APP](/img/mockups/09.png "The subcomponents of a `SearchBox`")]()

If we had no customization requirements, the pseudo-code implementing interactions between all three components would look rather trivial:

```typescript
class SearchBox implements ISearchBox {
  // The responsibility of `SearchBox` is:
  // 1. Creating a container for rendering
  // an offer list, prepare option values
  // and create the `OfferList` instance
  constructor(container, options) {
    …
    this.offerList = new OfferList(
      this,
      offerListContainer,
      offerListOptions
    );
  }
  // 2. Making an offer search when a user
  // presses the corresponding button and
  // to provide analogous programmable
  // interface for developers
  onSearchButtonClick() {
    this.search(this.searchInput.value);
  }
  search(query) {
    …
  }
  // 3. Notifying about new search results
  // being received from the server
  onSearchResultsReceived(searchResults) {
    …
    this.offerList.setOfferList(searchResults)
  }
  // 4. Creating orders (and manipulate sub-
  // components if needed)
  createOrder(offer) {
    this.offerListDestroy();
    ourCoffeeSdk.createOrder(offer);
    …
  }
  // 5. Self-destructing when requested to
  destroy() {
    this.offerList.destroy();
    …
  }
}
```
```typescript
class OfferList implements IOfferList {
  // The responsibility of `OfferList` is:
  // 1. Creating a container for rendering
  // an offer panel, prepare option values
  // and create the `OfferPanel` instance
  constructor(searchBox, container, options) {
    …
    this.offerPanel = new OfferPanel(
      searchBox,
      offerPanelContainer,
      offerPanelOptions
    );
    …
  }
  // 2. Providing a method to change the list
  // of offers to be presented
  setOfferList(offerList) { … }
  // 3. When an offer is selected, opening
  // an offer panel to present it
  onOfferClick(offer) {
    this.offerPanel.show(offer)
  }
  // 4. Self-destructing if requested to
  destroy() {
    this.offerPanel.destroy();
    …
  }
}
```
```typescript
class OfferPanel implements IOfferPanel {
  constructor(
    searchBox, container, options
  ) { … }
  // The responsibility of `OfferPanel` is:
  // 1. Presenting an offer
  show(offer) { 
    this.offer = offer;
    …
  }
  // 2. Creating an order when the user
  // presses the “Place an order” button
  onCreateOrderButtonClick() {
    this.searchBox.createOrder(this.offer);
  }
  // 3. Closing itself when the user
  // presses the “Not now” button
  onCancelButtonClick() {
    // …
  }
  // 4. Self-destructing if requested to
  destroy() { … }
}
```

The `ISearchBox` / `IOfferPanel` / `IOfferView` interfaces are concise as well (constructors and destructors omitted):

```typescript
interface ISearchBox {
  search(query);
  createOrder(offer);
}
interface IOfferList {
  setOfferList(offerList);
}
interface IOfferPanel {
  show(offer);
}
```

If we aren't making an SDK and have not had the task of making these components customizable, the approach would be perfectly viable. However, let's discuss how would we solve the three sample tasks described above.

  1. Displaying an offer list on the map: at first glance, we can develop an alternative component for displaying offers that implement the `IOfferList` interface (let's call it `OfferMap`) that will reuse the standard offer panel. However, we have a problem: `OfferList` only sends commands to `OfferPanel` while `OfferMap` also needs to receive feedback: an event of panel closure to deselect a marker. API of our components does not encompass this functionality, and implementing it is not that simple:

      ```typescript
      class CustomOfferPanel extends OfferPanel {
        constructor(
          searchBox, offerMap, container, options
        ) {
          this.offerMap = offerMap;
          super(searchBox, container, options);
        }
        onCancelButtonClick() {
          /* <em> */offerMap.resetCurrentOffer();/* </em> */
          super.onCancelButtonClick();
        }
      }
      class OfferMap implements IOfferList {
        constructor(searchBox, container, options) {
          …
          this.offerPanel = new CustomOfferPanel(
            this,
            searchBox,
            offerPanelContainer,
            offerPanelOptions
          )
        }
        resetCurrentOffer() { … }
        …
      }
      ```

      We have to create a `CustomOfferPanel` class, and this implementation, unlike its parent class, now only works with `OfferMap`, not with any `IOfferList`-compatible component.
  
  2. The case of making full offer details and action controls in place in the offer list is pretty obvious: we can achieve this only by writing a new `IOfferList`-compatible component from scratch as whatever overrides we apply to standard `OfferList`, it will continue creating an `OfferPanel` and open it upon offer selection.

  3. To implement new buttons, we can only propose developers creating a custom offer list component (to provide methods for selecting previous and next offers) and a custom offer panel that will call these methods. If we find a simple solution for customizing, let's say, the “Place an order” button text, this solution needs to be supported in the `OfferList` code:

      ```typescript
      const searchBox = new SearchBox(…, {
        /* <em> */offerPanelCreateOrderButtonText:
          'Drink overpriced coffee!'/* </em> */
      });

      class OfferList {
        constructor(…, options) {
          …
          // It is `OfferList`'s responsibility
          // to isolate the injection point and
          // to propagate the overriden value
          // to the `OfferPanel` instance
          this.offerPanel = new OfferPanel(…, {
            /* <em> */createOrderButtonText: options
              .offerPanelCreateOrderButtonText/* </em> */
            …
          })
        }
      }
      ```

The solutions we discuss are also poorly extendable. For example, in \#1, if we decide to make the offer list reaction to closing an offer panel a part of a standard interface for developers to use it, we will need to add a new method to the `IOfferList` interface and make it optional to maintain backward compatibility:

```typescript
interface IOfferList {
  …
  onOfferPanelClose?();
}
```

In the `OfferPanel` code, the support of this new method will look like:

```typescript
if (Type(this.offerList.onOfferPanelClose)
  == 'function') {
    this.offerList.onOfferPanelClose();
  }
```

For sure, this will not make our code any nicer. Additionally, `OfferList` and `OfferPanel` will become even more tightly coupled.