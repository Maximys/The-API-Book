{"data":{"counter":14,"refCounter":0,"stat":{"words":23603,"characters":110923},"l10n":{"title":"The API","author":"Sergey Konstantinov","chapter":"Chapter","toc":"Table of Contents","description":"Designing APIs is a very special skill: API is a multiplier to both your opportunities and mistakes. This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.","locale":"en_US","file":"API","aboutMe":{"title":"About the Author","content":["<p>Sergey Konstantinov has been working with APIs for more than a decade. He started his career as a software engineer in the Maps API division at Yandex and eventually became the head of the service, being responsible for both technical architecture and product management.</p>","<p>During this tenure, Sergey got a unique experience in building world-class APIs with a daily audience of tens of millions, planning roadmaps for such a service, and giving numerous public speeches. He also worked for a year and a half as a member of the W3C Technical Architecture Group.</p>","<p>After nine years in Maps, Sergey switched to technical-lead roles in other departments and companies, leading integration efforts and being responsible for the technical architecture of entire business units. Today, Sergey lives in Tallinn, Estonia, and works as a staff software engineer at Bolt.</p>"],"imageCredit":"Photo by <a href=\"http://linkedin.com/in/zloylos/\">Denis Hananein</a>"},"landingFile":"index.html","url":"https://twirl.github.io/The-API-Book/","favicon":"/img/favicon.png","sidePanel":{"shareTo":"Share","copyLink":"Link","shareParameters":{"url":"https://twirl.github.io/The-API-Book/","text":"The API by Sergey Konstantinov — a book about designing APIs, extending them and finding a proper place in the market","tags":"API,TheAPIBook","viaTwitter":"blogovodoved"},"services":[{"key":"facebook","link":"https://www.facebook.com/sharer.php?u=${url}"},{"key":"twitter","link":"https://twitter.com/intent/tweet?text=${text}&url=${url}&hashtags=${tags}&via=${viaTwitter}"},{"key":"linkedin","link":"https://www.linkedin.com/sharing/share-offsite/?url=${url}"},{"key":"reddit","link":"http://www.reddit.com/submit?url=${url}&title=${text}"}]},"imageCredit":"Image Credit","links":{"email":"yatwirl@gmail.com","emailString":"yatwirl@gmail.com","linkedinHref":"https://www.linkedin.com/in/twirl/","linkedinString":"linkedin.com/in/twirl","patreonHref":"https://www.patreon.com/yatwirl","patreonString":"patreon.com/yatwirl","patreonTag":"Patreon","githubHref":"https://github.com/twirl/The-API-Book","githubString":"github.com/twirl/The-API-Book","twitterHref":"https://twitter.com/blogovodoved","kindleHref":"https://www.amazon.com/gp/product/B09RHH44S5/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i0","kindleTag":"buy Kindle version","mediumHref":"https://twirl.medium.com/","mediumTag":"Medium"},"sourceCodeAt":"Source code available at","frontPage":{"title":"The API","pageTitle":"Front Page","contents":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p class=\"text-align-left\">Illustrations &amp; inspiration by Maria Konstantinova &middot; <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a></p>","<img class=\"cc-by-nc-img\" alt=\"Creative Commons «Attribution-NonCommercial» Logo\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"/>","<p class=\"cc-by-nc\">This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.</p>"]},"landing":{"subTitle":"Free e-book","subscribeOn":"Subscribe for updates on","updates":["github"],"followOn":"Follow me on","follow":["linkedin","twitter","medium"],"supportThisWork":"Support this work on","support":["patreon","kindle"],"content":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p>Illustration &amp; inspiration: <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a>.</p>"],"download":"You might download ‘The API’ in","or":"or","readOnline":"read it online","license":"This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.","footer":["<p>Книгу «API» можно <a href=\"index.ru.html\">читать по-русски</a>.</p>"]}},"base":"C:\\Users\\twirl_000\\Documents\\The-API-Book\\src","templates":{"pageBreak":"<div class=\"page-break\"></div>"},"anchor":"chapter-13","titleParts":["The Backwards Compatibility Problem Statement"],"localContext":null,"references":[],"title":"Chapter 13. The Backwards Compatibility Problem Statement"},"messages":[],"history":[],"cwd":"C:\\Users\\twirl_000\\Documents\\The-API-Book","value":"\n<p>As usual, let's conceptually define ‘backwards compatibility’ before we start.</p>\n<p>Backwards compatibility is a feature of the entire API system to be stable in time. It means the following: <strong>the code that developers have written using your API continues working functionally correctly for a long period of time</strong>. There are two important questions to this definition and two explanations:</p>\n<ol>\n<li>\n<p>What does ‘functionally correctly’ mean?</p>\n<p>It means that the code continues to serve its function, e.g. solve some users' problems. It doesn't mean it continues working indistinguishably: for example, if you're maintaining a UI library, changing functionally insignificant design details like shadow depth or border stoke type is backwards compatible, whereas changing visual components size is not.</p>\n</li>\n<li>\n<p>What does ‘a long period of time’ mean?</p>\n<p>From our point of view, the backwards compatibility maintenance period should be reconciled with the subject area application lifetime. Platform LTS periods are decent guidance in most cases. Since apps will be rewritten anyway when the platform maintenance period ends, it is reasonable to expect developers to move to the new API version also. In mainstream subject areas (e.g. desktop and mobile operating systems) this period lasts several years.</p>\n</li>\n</ol>\n<p>From the definition becomes obvious why backwards compatibility needs to be maintained (including taking necessary measures at the API design stage). An outage, full or partial, caused by the API vendor, is an extremely uncomfortable situation for every developer, if not a disaster — especially if they pay money for the API usage.</p>\n<p>But let's take a look at the problem from another angle: why the maintaining backwards compatibility problem exists at all? Why would anyone <em>want</em> to break it? This question, though it looks quite trivial, is much more complicated than the previous one.</p>\n<p>We could say the <em>we break backwards compatibility to introduce new features to the API</em>. But that would be deceiving: new features are called <em>‘new’</em> just because they cannot affect existing implementations which are not using them. We must admit there are several associated problems, which lead to the aspiration to rewrite <em>our</em> code, the code of the API itself, and ship a new major version:</p>\n<ul>\n<li>\n<p>the code eventually becomes outdated; making changes, even introducing totally new functionality, is impractical;</p>\n</li>\n<li>\n<p>the old interfaces aren't suited to encompass new features; we would love to extend existing entities with new properties, but simply couldn't;</p>\n</li>\n<li>\n<p>finally, with years passing since the initial release, we understood more about the subject area and API usage best practices, and we would implement many things differently.</p>\n</li>\n</ul>\n<p>These arguments could be summarized frankly as ‘the API developers don't want to support the old code’. But this explanation is still incomplete: even if you're not going to rewrite the API code to add new functionality, or you're not going to add it at all, you still have to ship new API versions, minor and major alike.</p>\n<p><strong>NB</strong>: in this chapter, we don't make any difference between minor versions and patches: ‘minor version’ means any backwards-compatible API release.</p>\n<p>Let us remind that <a href=\"(https://twirl.github.io/The-API-Book/docs/API.en.html#chapter-2)\">an API is a bridge</a>, a meaning of connecting different programmable contexts. No matter how strong our desire to keep the bridge intact is, our capabilities are limited: we could lock the bridge, but we cannot command the rifts and the canyon itself. That's the source of the problems: we can't guarantee that <em>our own</em> code won't change, so at some point, we will have to ask the clients to change <em>their</em> code.</p>\n<p>Apart from our aspirations to change the API architecture, three other tectonic processes are happening at the same time: user agents, subject areas, and underlying platforms' erosion.</p>\n<h4>Consumer applications fragmentation</h4>\n<p>When you shipped the very first API version, and the first clients started to use it, the situation was perfect. There was only one version, and all clients were using just it. When this perfection ends, two scenarios are possible.</p>\n<ol>\n<li>\n<p>If the platform allows for fetching code on-demand as the good old Web does, and you weren't too lazy to implement that code-on-demand feature (in a form of a platform SDK — for example, JS API), then the evolution of your API is more or less under your control. Maintaining backwards compatibility effectively means keeping <em>the client library</em> backwards-compatible. As for client-server interaction, you're free.</p>\n<p>It doesn't mean that you can't break backwards compatibility. You still can make a mess with cache-control headers or just overlook a bug in the code. Besides, even code-on-demand systems don't get updated instantly. The author of this book faced the situation when users were deliberately keeping a browser tab open <em>for weeks</em> to get rid of updates. But still, you usually don't have to support more than two API versions — the last one and the penultimate one. Furthermore, you may try to rewrite the previous major version of the library, implementing it on top of the actual API version.</p>\n</li>\n<li>\n<p>If the code-on-demand feature isn't supported or is prohibited by the platform, as in modern mobile operating systems, then the situation becomes more severe. Each client effectively borrows a snapshot of the code, working with your API, frozen at the moment of compilation. Client application updates are scattered over time at much more extent than Web application updates. The most painful thing is that <em>some clients will never be up to date</em>, because of one of the three reasons:</p>\n<ul>\n<li>developers simply don't want to update the app, e.g. its development stopped;</li>\n<li>users don't want to get updates (sometimes because users think that developers ‘spoiled’ the app in new versions);</li>\n<li>users can't get updates because their devices are no longer supported.</li>\n</ul>\n<p>In modern times these three categories combined could easily constitute tens of per cent of auditory. It implies that cutting the support of any API version might be remarkable — especially if developers' apps continue supporting a more broad spectrum of platforms than the API does.</p>\n<p>You could have never issued any SDK, providing just the server-side API, for example in a form of HTTP endpoints. You might think, given your API is less competitive on the market because of a lack of SDKs, that the backwards compatibility problem is mitigated. That's not true: if you don't provide an SDK, then developers will either adopt an unofficial one (if someone bothers to make it) or just write a framework themselves — independently. ‘Your framework — your problems’ strategy, fortunately or not, works badly: if developers write poor quality code upon your API, then your API is of poor quality itself. Definitely in the view of developers, possibly in the view of end-users, if the API performance within the app is visible to them.</p>\n</li>\n</ol>\n<p>Certainly, if you provide a stateless API that doesn't require client SDKs (or they might be auto-generated from the spec), those problems will be much less noticeable, but not fully avoidable, unless you never issue any new API version. If you do, you will still have to deal with some fragmentation of users by API and SDK versions.</p>\n<h4>Subject area evolution</h4>\n<p>The other side of the canyon is the underlying functionality you're exposing via the API. It's, of course, not static and somehow evolves:</p>\n<ul>\n<li>new functionality emerges;</li>\n<li>older functionality shuts down;</li>\n<li>interfaces change.</li>\n</ul>\n<p>As usual, the API provides an abstraction to a much more granular subject area. In the case of our <a href=\"https://twirl.github.io/The-API-Book/docs/API.en.html#chapter-7\">coffee machine API example</a> one might reasonably expect new models to pop up, which are to be supported by the platform. New models tend to provide new APIs, and it's hard to guarantee they might be adopted while preserving the same high-level API. And anyway, the code needs to be altered, which might lead to incompatibility, albeit unintentional.</p>\n<p>Let us also stress that low-level API vendors are not always as resolute regarding maintaining backwards compatibility for their APIs (actually, any software they provide) as (we hope so) you are. You should be warned that keeping your API in an operational state, e.g. writing and supporting facades to the shifting subject area landscape, will be your problem, and rather a sudden one.</p>\n<h4>Platform drift</h4>\n<p>Finally, there is a third side to a story — the ‘canyon’ you're crossing over with a bridge of your API. Developers write code that is executed in some environment you can't control, and it's evolving. New versions of operating systems, browsers, protocols, and programming language SDKs emerge. New standards are being developed, new arrangements made, some of them being backwards-incompatible, and nothing could be done about that.</p>\n<p>Older platform versions lead to fragmentation just like older app versions do, because developers (including the API developers) are struggling with supporting older platforms, and users are struggling with platform updates — and often can't update at all, since newer platform versions require newer devices.</p>\n<p>The nastiest thing here is that not only does incremental progress in a form of new platforms and protocols demand changing the API, but also does vulgar fashion. Several years ago realistic 3d icons were popular, but since then the public taste changed in a favor of flat and abstract ones. UI components developers had to follow the fashion, rebuilding their libraries, either shipping new icons or replacing old ones. Similarly, right now ‘night mode’ support is introduced everywhere, demanding changes in a broad range of APIs.</p>\n<h4>Backwards compatibility policy</h4>\n<p>To summarize the above:</p>\n<ul>\n<li>you will have to deploy new API versions because of apps, platforms, and subject area evolution; different areas are evolving at a different pace, but never stop doing so;</li>\n<li>that will lead to fragmenting the API versions usage over different platforms and apps;</li>\n<li>you have to make decisions critically important to your API's sustainability in the customers' view.</li>\n</ul>\n<p>Let's briefly describe these decisions and the key factors for making them.</p>\n<ol>\n<li>\n<p>How often new major API versions should be developed?</p>\n<p>That's primarily a <em>product</em> question. A new major API version is to be released when the critical mass of functionality is reached — a critical mass of features that couldn't be introduced in the previous API versions, or introducing them is too expensive. In stable markets, such a situation occurs once in several years, usually. In emerging markets, new API major versions might be shipped more frequently, only depending on your capabilities of supporting the zoo of previous versions. However, we should note that deploying a new version before the previous one was stabilized (which commonly takes from several months up to a year) is always a troubling sign to developers, meaning they're risking dealing with the unfinished platform glitches permanently.</p>\n</li>\n<li>\n<p>How many <em>major</em> versions should be supported at a time?</p>\n<p>As for major versions, we gave <em>theoretical</em> advice earlier: ideally, the major API version lifecycle should be a bit longer than the platform's one. In stable niches like desktop operating systems, it constitutes 5 to 10 years. In new and emerging ones, it is less but still measured in years. <em>Practically</em> speaking you should look at the size of the auditory which continues using older versions.</p>\n</li>\n<li>\n<p>How many <em>minor</em> versions (within one major version) should be supported at a time?</p>\n<p>As for minor versions, there are two options:</p>\n<ul>\n<li>if you provide server-side APIs and compiled SDKs only, you may basically do not expose minor versions at all, just the actual one: the server-side API is totally within your control, and you may fix any problem efficiently;</li>\n<li>if you provide code-on-demand SDKs, it is considered a good form to provide an access to previous minor versions of SDK for a period of time sufficient enough for developers to test their application and fix some issues if necessary. Since full rewriting isn't necessary, it's fine to align with apps release cycle duration in your industry, which is usually several months in worst cases.</li>\n</ul>\n</li>\n</ol>\n<h4>Simultaneous access to several API versions</h4>\n<p>In modern professional software development, especially if we talk about internal APIs, a new API version usually fully replaces the previous one. If some problems are found, it might be rolled back (by releasing the previous version), but the two builds never co-exist. However, in the case of public APIs, the more the number of partner integrations is, the more dangerous this approach becomes.</p>\n<p>Indeed, with the growth of the number of users, the ‘rollback the API version in case of problems’ paradigm becomes increasingly destructive. To a partner, the optimal solution is rigidly referencing the specific API version — the one that had been tested (ideally, at the same time having the API vendor somehow seamlessly fixing security issues and making their software compliant with newly introduced legislation).</p>\n<p><strong>NB</strong>. From the same considerations, providing beta (or maybe even alpha) versions of the popular APIs becomes more and more desirable as well, to make partners test the upcoming version and address the possible issues in advance.</p>\n<p>The important (and undeniable) advantage of the <em>semver</em> system is that it provides the proper version granularity:</p>\n<ul>\n<li>stating the first digit (major version) allows for getting a backwards-compatible version of the API;</li>\n<li>stating two digits (major and minor versions) allows to guarantee that some functionality that was added after the initial release will be available;</li>\n<li>finally, stating all three numbers (major version, minor version, and patch) allows for fixing a concrete API release with all its specificities (and errors), which — theoretically — means that the integration will remain operable till this version is physically available.</li>\n</ul>\n<p>Of course, preserving minor versions infinitely isn't possible (partly because of security and compliance issues that tend to pile up). However, providing such access for a reasonable period of time is rather a hygienic norm for popular APIs.</p>\n<p><strong>NB</strong>. Sometimes to defend the single accessible API version concept, the following argument is put forward: preserving the SDK or API application server code is not enough to maintain strict backwards compatibility, as it might be relying on some un-versioned services (for example, some data in the DB that are shared between all the API versions). We, however, consider this an additional reason to isolate such dependencies (see ‘The Serenity Notepad’ chapter) as it means that changes to these subsystems might lead to the inoperability of the API.</p>"}