{"data":{"counter":15,"refCounter":0,"stat":{"words":25354,"characters":119643},"l10n":{"title":"The API","author":"Sergey Konstantinov","chapter":"Chapter","toc":"Table of Contents","description":"Designing APIs is a very special skill: API is a multiplier to both your opportunities and mistakes. This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.","locale":"en_US","file":"API","aboutMe":{"title":"About the Author","content":["<p>Sergey Konstantinov has been working with APIs for more than a decade. He started his career as a software engineer in the Maps API division at Yandex and eventually became the head of the service, being responsible for both technical architecture and product management.</p>","<p>During this tenure, Sergey got a unique experience in building world-class APIs with a daily audience of tens of millions, planning roadmaps for such a service, and giving numerous public speeches. He also worked for a year and a half as a member of the W3C Technical Architecture Group.</p>","<p>After nine years in Maps, Sergey switched to technical-lead roles in other departments and companies, leading integration efforts and being responsible for the technical architecture of entire business units. Today, Sergey lives in Tallinn, Estonia, and works as a staff software engineer at Bolt.</p>"],"imageCredit":"Photo by <a href=\"http://linkedin.com/in/zloylos/\">Denis Hananein</a>"},"landingFile":"index.html","url":"https://twirl.github.io/The-API-Book/","favicon":"/img/favicon.png","sidePanel":{"shareTo":"Share","copyLink":"Link","shareParameters":{"url":"https://twirl.github.io/The-API-Book/","text":"The API by Sergey Konstantinov — a book about designing APIs, extending them and finding a proper place in the market","tags":"API,TheAPIBook","viaTwitter":"blogovodoved"},"services":[{"key":"facebook","link":"https://www.facebook.com/sharer.php?u=${url}"},{"key":"twitter","link":"https://twitter.com/intent/tweet?text=${text}&url=${url}&hashtags=${tags}&via=${viaTwitter}"},{"key":"linkedin","link":"https://www.linkedin.com/sharing/share-offsite/?url=${url}"},{"key":"reddit","link":"http://www.reddit.com/submit?url=${url}&title=${text}"}]},"imageCredit":"Image Credit","links":{"email":"yatwirl@gmail.com","emailString":"yatwirl@gmail.com","linkedinHref":"https://www.linkedin.com/in/twirl/","linkedinString":"linkedin.com/in/twirl","patreonHref":"https://www.patreon.com/yatwirl","patreonString":"patreon.com/yatwirl","patreonTag":"Patreon","githubHref":"https://github.com/twirl/The-API-Book","githubString":"github.com/twirl/The-API-Book","twitterHref":"https://twitter.com/blogovodoved","kindleHref":"https://www.amazon.com/gp/product/B09RHH44S5/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i0","kindleTag":"buy Kindle version","mediumHref":"https://twirl.medium.com/","mediumTag":"Medium"},"sourceCodeAt":"Source code available at","frontPage":{"title":"The API","pageTitle":"Front Page","contents":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p class=\"text-align-left\">Illustrations &amp; inspiration by Maria Konstantinova &middot; <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a></p>","<img class=\"cc-by-nc-img\" alt=\"Creative Commons «Attribution-NonCommercial» Logo\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"/>","<p class=\"cc-by-nc\">This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.</p>"]},"landing":{"subTitle":"Free e-book","subscribeOn":"Subscribe for updates on","updates":["github"],"followOn":"Follow me on","follow":["linkedin","twitter","medium"],"supportThisWork":"Support this work on","support":["patreon","kindle"],"content":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p>Illustration &amp; inspiration: <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a>.</p>"],"download":"You might download ‘The API’ in","or":"or","readOnline":"read it online","license":"This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.","footer":["<p>Книгу «API» можно <a href=\"index.ru.html\">читать по-русски</a>.</p>"]}},"base":"C:\\Users\\twirl_000\\Documents\\The-API-Book\\src","templates":{"pageBreak":"<div class=\"page-break\"></div>"},"anchor":"chapter-14","titleParts":["On the Waterline of the Iceberg"],"localContext":null,"references":[],"title":"Chapter 14. On the Waterline of the Iceberg"},"messages":[],"history":[],"cwd":"C:\\Users\\twirl_000\\Documents\\The-API-Book","value":"\n<p>Before we start talking about the extensible API design, we should discuss the hygienic minimum. A huge number of problems would have never happened if API vendors had paid more attention to marking their area of responsibility.</p>\n<h5><a href=\"#chapter-14-paragraph-1\" id=\"chapter-14-paragraph-1\" class=\"anchor\">1. Provide a minimal amount of functionality</a></h5>\n<p>At any moment in its lifetime, your API is like an iceberg: it comprises an observable (e.g. documented) part and a hidden one, undocumented. If the API is designed properly, these two parts correspond to each other just like the above-water and under-water parts of a real iceberg do, i.e. one to ten. Why so? Because of two obvious reasons.</p>\n<ul>\n<li>\n<p>Computers exist to make complicated things easy, not vice versa. The code developers write upon your API must describe a complicated problem's solution in neat and straightforward sentences. If developers have to write more code than the API itself comprises, then there is something rotten here. Probably, this API simply isn't needed at all.</p>\n</li>\n<li>\n<p>Revoking the API functionality causes losses. If you've promised to provide some functionality, you will have to do so ‘forever’ (until this API version's maintenance period is over). Pronouncing some functionality deprecated is a tricky thing, potentially alienating your customers.</p>\n</li>\n</ul>\n<p>Rule #1 is the simplest: if some functionality might be withheld — then never expose it. It might be reformulated like: every entity, every field, and every public API method is a <em>product solution</em>. There must be solid <em>product</em> reasons why some functionality is exposed.</p>\n<h5><a href=\"#chapter-14-paragraph-2\" id=\"chapter-14-paragraph-2\" class=\"anchor\">2. Avoid gray zones and ambiguities</a></h5>\n<p>Your obligations to maintain some functionality must be stated as clearly as possible. Especially regarding those environments and platforms where no native capability to restrict access to undocumented functionality exists. Unfortunately, developers tend to consider some private features they found to be eligible for use, thus presuming the API vendor shall maintain them intact. Policy on such ‘findings’ must be articulated explicitly. At the very least, in case of such non-authorized usage of undocumented functionality, you might refer to the docs, and be in your own rights in the eyes of the community.</p>\n<p>However, API developers often legitimize such gray zones themselves, for example, by:</p>\n<ul>\n<li>returning undocumented fields in endpoints' responses;</li>\n<li>using private functionality in code examples — in the docs, responding to support messages, in conference talks, etc.</li>\n</ul>\n<p>One cannot make a partial commitment. Either you guarantee this code will always work or do not slip the slightest note such functionality exists.</p>\n<h5><a href=\"#chapter-14-paragraph-3\" id=\"chapter-14-paragraph-3\" class=\"anchor\">3. Codify implicit agreements</a></h5>\n<p>The third principle is much less obvious. Pay close attention to the code which you're suggesting developers to develop: are there any conventions that you consider evident, but never wrote them down?</p>\n<p><strong>Example #1</strong>. Let's take a look at this order processing SDK example:</p>\n<pre><code>// Creates an order\nlet order = api.createOrder();\n// Returns the order status\nlet status = api.getStatus(order.id);\n</code></pre>\n<p>Let's imagine that you're struggling with scaling your service, and at some point moved to the asynchronous replication of the database. This would lead to the situation when querying for the order status right after order creating might return <code>404</code> if an asynchronous replica hasn't got the update yet. In fact, thus we abandon a strict <a href=\"https://en.wikipedia.org/wiki/Consistency_model\">consistency policy</a> in a favor of an eventual one.</p>\n<p>What would be the result? The code above will stop working. A developer creates an order, then tries to get its status — but gets the error. It's very hard to predict what approach developers would implement to tackle this error. Probably, none at all.</p>\n<p>You may say something like, ‘But we've never promised the strict consistency in the first place’ — and that is obviously not true. You may say that if, and only if, you have really described the eventual consistency in the <code>createOrder</code> docs, and all your SDK examples look like:</p>\n<pre><code>let order = api.createOrder();\nlet status;\nwhile (true) {\n    try {\n        status = api.getStatus(order.id);\n    } catch (e) {\n        if (e.httpStatusCode != 404 ||\n            timeoutExceeded()) {\n            break;\n        }\n    }\n}\nif (status) {\n    …\n}\n</code></pre>\n<p>We presume we may skip the explanations why such code must never be written under any circumstances. If you're really providing a non-strictly consistent API, then either the <code>createOrder</code> operation must be asynchronous and return the result when all replicas are synchronized, or the retry policy must be hidden inside the <code>getStatus</code> operation implementation.</p>\n<p>If you failed to describe the eventual consistency in the first place, then you simply can't make these changes in the API. You will effectively break backwards compatibility, which will lead to huge problems with your customers' apps, intensified by the fact they can't be simply reproduced.</p>\n<p><strong>Example #2</strong>. Take a look at the following code:</p>\n<pre><code>let resolve;\nlet promise = new Promise(\n    function (innerResolve) {\n        resolve = innerResolve;\n    }\n);\nresolve();\n</code></pre>\n<p>This code presumes that the callback function passed to a <code>new Promise</code> will be executed synchronously, and the <code>resolve</code> variable will be initialized before the <code>resolve()</code> function is called. But this assumption is based on nothing: there are no clues indicating the <code>new Promise</code> constructor executes the callback function synchronously.</p>\n<p>Of course, the developers of the language standard can afford such tricks; but you as an API developer cannot. You must at least document this behavior and make the signatures point to it; actually, good advice is to avoid such conventions, since they are simply unobvious while reading the code. And of course, under no circumstances, you can actually change this behavior to an asynchronous one.</p>\n<p><strong>Example #3</strong>. Imagine you're providing animations API, which includes two independent functions:</p>\n<pre><code>// Animates object's width,\n// beginning with first value, \n// ending with second\n// in a specified time period\nobject.animateWidth(\n  '100px', '500px', '1s'\n);\n// Observes object's width changes\nobject.observe(\n  'widthchange', observerFunction\n);\n</code></pre>\n<p>A question arises: how frequently and at what time fractions the <code>observerFunction</code> will be called? Let's assume in the first SDK version we emulated step-by-step animation at 10 frames per second: then the <code>observerFunction</code> will be called 10 times, getting values '140px', '180px', etc., up to '500px'. But then in a new API version, we switched to implementing both functions atop of a system's native functionality — and so you simply don't know, when and how frequently the <code>observerFunction</code> will be called.</p>\n<p>Just changing call frequency might result in making some code dysfunctional — for example, if the callback function makes some complex calculations, and no throttling is implemented since the developer just relied on your SDK's built-in throttling. And if the <code>observerFunction</code> ceases to be called when exactly '500px' is reached because of some system algorithms specifics, some code will be broken beyond any doubt.</p>\n<p>In this example, you should document the concrete contract (how often the observer function is called) and stick to it even if the underlying technology is changed.</p>\n<p><strong>Example #4</strong>. Imagine that customer orders are passing through a specific pipeline:</p>\n<pre><code>GET /v1/orders/{id}/events/history\n→\n{ \"event_history\": [\n  {\n    \"iso_datetime\": \n      \"2020-12-29T00:35:00+03:00\",\n    \"new_status\": \"created\"\n  }, {\n    \"iso_datetime\": \n      \"2020-12-29T00:35:10+03:00\",\n    \"new_status\": \"payment_approved\"\n  }, {\n    \"iso_datetime\": \n      \"2020-12-29T00:35:20+03:00\",\n    \"new_status\": \"preparing_started\"\n  }, {\n    \"iso_datetime\": \n      \"2020-12-29T00:35:30+03:00\",\n    \"new_status\": \"ready\"\n  }\n]}\n</code></pre>\n<p>Suppose at some moment we decided to allow trustworthy clients to get their coffee in advance before the payment is confirmed. So an order will jump straight to \"preparing_started\", or event \"ready\", without a \"payment_approved\" event being emitted. It might appear to you that this modification <em>is</em> backwards-compatible since you've never really promised any specific event order being maintained, but it is not.</p>\n<p>Let's assume that a developer (probably, your company's business partner) wrote some code implementing some valuable business procedure, for example, gathering income and expenses analytics. It's quite logical to expect this code operates a state machine, which switches from one state to another depending on getting (or getting not) specific events. This analytical code will be broken if the event order changes. In the best-case scenario, a developer will get some exceptions and have to cope with the error's cause; the worst-case, partners will operate wrong statistics for an indefinite period of time until they find a mistake.</p>\n<p>A proper decision would be, first, documenting the event order and the allowed states; second, continuing generating the \"payment_approved\" event before the \"preparing_started\" one (since you're making a decision to prepare that order, so you're in fact approving the payment) and add extended payment information.</p>\n<p>This example leads us to the last rule.</p>\n<h5><a href=\"#chapter-14-paragraph-4\" id=\"chapter-14-paragraph-4\" class=\"anchor\">4. Product logic must be backwards-compatible as well</a></h5>\n<p>State transition graph, event order, possible causes of status changes — such critical things must be documented. Not every piece of business logic might be defined in a form of a programmatical contract; some cannot be represented at all.</p>\n<p>Imagine that one day you start to take phone calls. A client may contact the call center to cancel an order. You might even make this functionality <em>technically</em> backwards-compatible, introducing new fields to the ‘order’ entity. But the end-user might simply <em>know</em> the number, and call it even if the app wasn't suggesting anything like that. Partner's business analytical code might be broken likewise, or start displaying weather on Mars since it was written knowing nothing about the possibility of canceling orders somehow in circumvention of the partner's systems.</p>\n<p>A <em>technically</em> correct decision would be to add a ‘canceling via call center allowed’ parameter to the order creation function. Conversely, call center operators may only cancel those orders which were created with this flag set. But that would be a bad decision from a <em>product</em> point of view. The only ‘good’ decision in this situation is to foresee the possibility of external order cancellations in the first place. If you haven't foreseen it, your only option is the ‘Serenity Notepad’ to be discussed in the last chapter of this Section.</p>"}