{"data":{"counter":17,"refCounter":0,"stat":{"words":28428,"characters":134440},"l10n":{"title":"The API","author":"Sergey Konstantinov","chapter":"Chapter","toc":"Table of Contents","description":"Designing APIs is a very special skill: API is a multiplier to both your opportunities and mistakes. This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.","locale":"en_US","file":"API","aboutMe":{"title":"About the Author","content":["<p>Sergey Konstantinov has been working with APIs for more than a decade. He started his career as a software engineer in the Maps API division at Yandex and eventually became the head of the service, being responsible for both technical architecture and product management.</p>","<p>During this tenure, Sergey got a unique experience in building world-class APIs with a daily audience of tens of millions, planning roadmaps for such a service, and giving numerous public speeches. He also worked for a year and a half as a member of the W3C Technical Architecture Group.</p>","<p>After nine years in Maps, Sergey switched to technical-lead roles in other departments and companies, leading integration efforts and being responsible for the technical architecture of entire business units. Today, Sergey lives in Tallinn, Estonia, and works as a staff software engineer at Bolt.</p>"],"imageCredit":"Photo by <a href=\"http://linkedin.com/in/zloylos/\">Denis Hananein</a>"},"landingFile":"index.html","url":"https://twirl.github.io/The-API-Book/","favicon":"/img/favicon.png","sidePanel":{"shareTo":"Share","copyLink":"Link","shareParameters":{"url":"https://twirl.github.io/The-API-Book/","text":"The API by Sergey Konstantinov — a book about designing APIs, extending them and finding a proper place in the market","tags":"API,TheAPIBook","viaTwitter":"blogovodoved"},"services":[{"key":"facebook","link":"https://www.facebook.com/sharer.php?u=${url}"},{"key":"twitter","link":"https://twitter.com/intent/tweet?text=${text}&url=${url}&hashtags=${tags}&via=${viaTwitter}"},{"key":"linkedin","link":"https://www.linkedin.com/sharing/share-offsite/?url=${url}"},{"key":"reddit","link":"http://www.reddit.com/submit?url=${url}&title=${text}"}]},"imageCredit":"Image Credit","links":{"email":"yatwirl@gmail.com","emailString":"yatwirl@gmail.com","linkedinHref":"https://www.linkedin.com/in/twirl/","linkedinString":"linkedin.com/in/twirl","patreonHref":"https://www.patreon.com/yatwirl","patreonString":"patreon.com/yatwirl","patreonTag":"Patreon","githubHref":"https://github.com/twirl/The-API-Book","githubString":"github.com/twirl/The-API-Book","twitterHref":"https://twitter.com/blogovodoved","kindleHref":"https://www.amazon.com/gp/product/B09RHH44S5/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i0","kindleTag":"buy Kindle version","mediumHref":"https://twirl.medium.com/","mediumTag":"Medium"},"sourceCodeAt":"Source code available at","frontPage":{"title":"The API","pageTitle":"Front Page","contents":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p class=\"text-align-left\">Illustrations &amp; inspiration by Maria Konstantinova &middot; <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a></p>","<img class=\"cc-by-nc-img\" alt=\"Creative Commons «Attribution-NonCommercial» Logo\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"/>","<p class=\"cc-by-nc\">This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.</p>"]},"landing":{"subTitle":"Free e-book","subscribeOn":"Subscribe for updates on","updates":["github"],"followOn":"Follow me on","follow":["linkedin","twitter","medium"],"supportThisWork":"Support this work on","support":["patreon","kindle"],"content":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p>Illustration &amp; inspiration: <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a>.</p>"],"download":"You might download ‘The API’ in","or":"or","readOnline":"read it online","license":"This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.","footer":["<p>Книгу «API» можно <a href=\"index.ru.html\">читать по-русски</a>.</p>"]}},"base":"C:\\Users\\twirl_000\\Documents\\The-API-Book\\src","templates":{"pageBreak":"<div class=\"page-break\"></div>"},"anchor":"chapter-16","titleParts":["Strong Coupling and Related Problems"],"localContext":null,"references":[],"title":"Chapter 16. Strong Coupling and Related Problems"},"messages":[],"history":[],"cwd":"C:\\Users\\twirl_000\\Documents\\The-API-Book","value":"\n<p>To demonstrate the strong coupling problematics let us move to <em>really interesting</em> things. Let's continue our ‘variation analysis’: what if the partners wish to offer not only the standard beverages but their own unique coffee recipes to end-users? There is a catch in this question: the partner API as we described it in the previous chapter, does not expose the very existence of the partner network to the end-user, and thus describes a simple case. Once we start providing methods to alter the core functionality, not just API extensions, we will soon face next-level problems.</p>\n<p>So, let us add one more endpoint to register the partner's own recipe:</p>\n<pre><code>// Adds new recipe\nPOST /v1/recipes\n{\n  \"id\",\n  \"product_properties\": {\n    \"name\",\n    \"description\",\n    \"default_value\"\n    // Other properties, describing\n    // a beverage to end-user\n    …\n  }\n}\n</code></pre>\n<p>At first glance, again, it looks like a reasonably simple interface, explicitly decomposed into abstraction levels. But let us imagine the future — what would happen with this interface when our system evolves further?</p>\n<p>The first problem is obvious to those who read <a href=\"#chapter-11-paragraph-20\">chapter 11</a> thoroughly: product properties must be localized. That will lead us to the first change:</p>\n<pre><code>\"product_properties\": {\n  // \"l10n\" is a standard abbreviation\n  // for \"localization\"\n  \"l10n\" : [{\n    \"language_code\": \"en\", \n    \"country_code\": \"US\", \n    \"name\", \n    \"description\" \n  }, /* other languages and countries */ … ]\n]\n</code></pre>\n<p>And here the first big question arises: what should we do with the <code>default_volume</code> field? From one side, that's an objective quality measured in standardized units, and it's being passed to the program execution engine. On the other side, in countries like the United States, we had to specify beverage volume not like ‘300 ml’, but ‘10 fl oz’. We may propose two solutions:</p>\n<ul>\n<li>either the partner provides the corresponding number only, and we will make readable descriptions on our own behalf,</li>\n<li>or the partner provides both the number and all of its localized representations.</li>\n</ul>\n<p>The flaw in the first option is that a partner might be willing to use the service in some new country or language — and will be unable to do so until the API supports them. The flaw in the second option is that it works with predefined volumes only, so you can't order an arbitrary beverage volume. So the very first step we've made effectively has us trapped.</p>\n<p>The localization flaws are not the only problem with this API. We should ask ourselves a question — <em>why</em> do we really need these <code>name</code> and <code>description</code>? They are simply non-machine-readable strings with no specific semantics. At first glance, we need them to return them back in the <code>/v1/search</code> method response, but that's not a proper answer: why do we really return these strings from <code>search</code>?</p>\n<p>The correct answer lies a way beyond this specific interface. We need them <em>because some representation exists</em>. There is a UI for choosing beverage type. Probably the <code>name</code> and <code>description</code> fields are simply two designations of the beverage for a user to read, a short one (to be displayed on the search results page) and a long one (to be displayed in the extended product specification block). It actually means that we are setting the requirements to the API based on some very specific design. But <em>what if</em> a partner is making their own UI for their own app? Not only they might not actually need two descriptions, but we are also <em>deceiving</em> them. The <code>name</code> is not ‘just a name’ actually, it implies some restrictions: it has recommended length which is optimal to some specific UI, and it must look consistently on the search results page. Indeed, ‘our best quality™ coffee’ or ‘Invigorating Morning Freshness®’ designation would look very weird in between ‘Cappuccino’, ‘Lungo’, and ‘Latte’.</p>\n<p>There is also another side to this story. As UIs (both ours and partners) tend to evolve, new visual elements will be eventually introduced. For example, a picture of a beverage, its energy value, allergen information, etc. <code>product_properties</code> will become a scrapyard for tons of optional fields, and learning how setting what field results in what effects in the UI will be an interesting quest, full of probes and mistakes.</p>\n<p>Problems we're facing are the problems of <em>strong coupling</em>. Each time we offer an interface like described above, we in fact prescript implementing one entity (recipe) based on implementations of other entities (UI layout, localization rules). This approach disrespects the very basic principle of the ‘top to bottom’ API design because <strong>low-level entities must not define high-level ones</strong>.</p>\n<h4>The rule of contexts</h4>\n<p>To make things worse, let us state that the inverse principle is actually correct either: high-level entities must not define low-level ones, since that simply isn't their responsibility. The exit from this logical labyrinth is that high-level entities must <em>define a context</em>, which other objects are to interpret. To properly design adding a new recipe interface we shouldn't try to find a better data format; we need to understand what contexts, both explicit and implicit, exist in our subject area.</p>\n<p>We have already found a localization context. There is some set of languages and regions we support in our API, and there are requirements — what exactly the partner must provide to make our API work in a new region. More specifically, there must be some formatting function to represent beverage volume somewhere in our API code:</p>\n<pre><code>l10n.volume.format(\n  value, language_code, country_code\n)\n// l10n.formatVolume(\n//   '300ml', 'en', 'UK'\n// ) → '300 ml'\n// l10n.formatVolume(\n//   '300ml', 'en', 'US'\n// ) → '10 fl oz'\n</code></pre>\n<p>To make our API work correctly with a new language or region, the partner must either define this function or point which pre-existing implementation to use. Like this:</p>\n<pre><code>// Add a general formatting rule\n// for Russian language\nPUT /formatters/volume/ru\n{\n  \"template\": \"{volume} мл\"\n}\n// Add a specific formatting rule\n// for Russian language in the ‘US’ region\nPUT /formatters/volume/ru/US\n{\n  // in US we need to recalculate\n  // the number, then add a postfix\n  \"value_preparation\": {\n    \"action\": \"divide\",\n    \"divisor\": 30\n  },\n  \"template\": \"{volume} ун.\"\n}\n</code></pre>\n<p><strong>NB</strong>: we are more than aware that such a simple format isn't enough to cover real-world localization use-cases, and one either relies on existing libraries or designs a sophisticated format for such templating, which takes into account such things as grammatical cases and rules of rounding numbers up or allow defining formatting rules in a form of function code. The example above is simplified for purely educational purposes.</p>\n<p>Let us deal with the <code>name</code> and <code>description</code> problem then. To lower the coupling level there we need to formalize (probably just to ourselves) a ‘layout’ concept. We are asking for providing <code>name</code> and <code>description</code> not because we just need them, but for representing them in some specific user interface. This specific UI might have an identifier or a semantic name.</p>\n<pre><code>GET /v1/layouts/{layout_id}\n{\n  \"id\",\n  // We would probably have lots of layouts,\n  // so it's better to enable extensibility\n  // from the beginning\n  \"kind\": \"recipe_search\",\n  // Describe every property we require\n  // to have this layout rendered properly\n  \"properties\": [{\n    // Since we learned that `name`\n    // is actually a title for a search\n    // result snippet, it's much more\n    // convenient to have explicit\n    // `search_title` instead\n    \"field\": \"search_title\",\n    \"view\": {\n      // Machine-readable description\n      // of how this field is rendered\n      \"min_length\": \"5em\",\n      \"max_length\": \"20em\",\n      \"overflow\": \"ellipsis\"\n    }\n  }, …],\n  // Which fields are mandatory\n  \"required\": [\n    \"search_title\", \n    \"search_description\"\n  ]\n}\n</code></pre>\n<p>So the partner may decide, which option better suits them. They can provide mandatory fields for the standard layout:</p>\n<pre><code>PUT /v1/recipes/{id}/properties/l10n/{lang}\n{\n  \"search_title\", \"search_description\"\n}\n</code></pre>\n<p>or create a layout of their own and provide data fields it requires:</p>\n<pre><code>POST /v1/layouts\n{\n  \"properties\"\n}\n→\n{ \"id\", \"properties\" }\n</code></pre>\n<p>or they may ultimately design their own UI and don't use this functionality at all, defining neither layouts nor data fields.</p>\n<p>Then our interface would ultimately look like this:</p>\n<pre><code>POST /v1/recipes\n{ \"id\" }\n→\n{ \"id\" }\n</code></pre>\n<p>This conclusion might look highly counter-intuitive, but lacking any fields in a ‘Recipe’ simply tells us that this entity possesses no specific semantics of its own, and is simply an identifier of a context; a method to point out where to look for the data needed by other entities. In the real world we should implement a builder endpoint capable of creating all the related contexts with a single request:</p>\n<pre><code>POST /v1/recipe-builder\n{\n  \"id\",\n  // Recipe's fixed properties\n  \"product_properties\": {\n    \"default_volume\",\n    \"l10n\"\n  },\n  // Create all the desirable layouts\n  \"layouts\": [{\n    \"id\", \"kind\", \"properties\"\n  }],\n  // Add all the formatters needed\n  \"formatters\": {\n    \"volume\": [\n      { \n        \"language_code\", \n        \"template\" \n      }, { \n        \"language_code\", \n        \"country_code\", \n        \"template\" \n      }\n    ]\n  },\n  // Other actions needed to be done\n  // to register new recipe in the system\n  …\n}\n</code></pre>\n<p>We should also note that providing a newly created entity identifier by the requesting side isn't exactly the best pattern. However, since we decided from the very beginning to keep recipe identifiers semantically meaningful, we have to live with this convention. Obviously, we're risking getting lots of collisions on recipe names used by different partners, so we actually need to modify this operation: either the partner must always use a pair of identifiers (i.e. recipe's one plus partner's own id), or we need to introduce composite identifiers, as we recommended earlier in <a href=\"#chapter-11-paragraph-8\">Chapter 11</a>.</p>\n<pre><code>POST /v1/recipes/custom\n{\n  // First part of the composite\n  // identifier, for example,\n  // the partner's own id\n  \"namespace\": \"my-coffee-company\",\n  // Second part of the identifier\n  \"id_component\": \"lungo-customato\"\n}\n→\n{\n  \"id\": \n    \"my-coffee-company:lungo-customato\"\n}\n</code></pre>\n<p>Also note that this format allows us to maintain an important extensibility point: different partners might have totally isolated namespaces, or conversely share them. Furthermore, we might introduce special namespaces (like ‘common’, for example) to allow for publishing new recipes for everyone (and that, by the way, would allow us to organize our own backoffice to edit recipes).</p>"}