{"data":{"counter":11,"refCounter":0,"stat":{"words":11102,"characters":51734},"l10n":{"title":"The API","author":"Sergey Konstantinov","chapter":"Chapter","toc":"Table of Contents","description":"Designing APIs is a very special skill: API is a multiplier to both your opportunities and mistakes. This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.","locale":"en_US","file":"API","aboutMe":{"title":"About the Author","content":["<p>Sergey Konstantinov has been working with APIs for more than a decade. He started his career as a software engineer in the Maps API division at Yandex and eventually became the head of the service, being responsible for both technical architecture and product management.</p>","<p>During this tenure, Sergey got a unique experience in building world-class APIs with a daily audience of tens of millions, planning roadmaps for such a service, and giving numerous public speeches. He also worked for a year and a half as a member of the W3C Technical Architecture Group.</p>","<p>After nine years in Maps, Sergey switched to technical-lead roles in other departments and companies, leading integration efforts and being responsible for the technical architecture of entire business units. Today, Sergey lives in Tallinn, Estonia, and works as a staff software engineer at Bolt.</p>"],"imageCredit":"Photo by <a href=\"http://linkedin.com/in/zloylos/\">Denis Hananein</a>"},"landingFile":"index.html","url":"https://twirl.github.io/The-API-Book/","favicon":"/img/favicon.png","sidePanel":{"shareTo":"Share","copyLink":"Link","shareParameters":{"url":"https://twirl.github.io/The-API-Book/","text":"The API by Sergey Konstantinov — a book about designing APIs, extending them and finding a proper place in the market","tags":"API,TheAPIBook","viaTwitter":"blogovodoved"},"services":[{"key":"facebook","link":"https://www.facebook.com/sharer.php?u=${url}"},{"key":"twitter","link":"https://twitter.com/intent/tweet?text=${text}&url=${url}&hashtags=${tags}&via=${viaTwitter}"},{"key":"linkedin","link":"https://www.linkedin.com/sharing/share-offsite/?url=${url}"},{"key":"reddit","link":"http://www.reddit.com/submit?url=${url}&title=${text}"}]},"imageCredit":"Image Credit","links":{"email":"yatwirl@gmail.com","emailString":"yatwirl@gmail.com","linkedinHref":"https://www.linkedin.com/in/twirl/","linkedinString":"linkedin.com/in/twirl","patreonHref":"https://www.patreon.com/yatwirl","patreonString":"patreon.com/yatwirl","patreonTag":"Patreon","githubHref":"https://github.com/twirl/The-API-Book","githubString":"github.com/twirl/The-API-Book","twitterHref":"https://twitter.com/blogovodoved","kindleHref":"https://www.amazon.com/gp/product/B09RHH44S5/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i0","kindleTag":"buy Kindle version","mediumHref":"https://twirl.medium.com/","mediumTag":"Medium"},"sourceCodeAt":"Source code available at","frontPage":{"title":"The API","pageTitle":"Front Page","contents":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p class=\"text-align-left\">Illustrations &amp; inspiration by Maria Konstantinova &middot; <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a></p>","<img class=\"cc-by-nc-img\" alt=\"Creative Commons «Attribution-NonCommercial» Logo\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"/>","<p class=\"cc-by-nc\">This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.</p>"]},"landing":{"subTitle":"Free e-book","subscribeOn":"Subscribe for updates on","updates":["github"],"followOn":"Follow me on","follow":["linkedin","twitter","medium"],"supportThisWork":"Support this work on","support":["patreon","kindle"],"content":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p>Illustration &amp; inspiration: <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a>.</p>"],"download":"You might download ‘The API’ in","or":"or","readOnline":"read it online","license":"This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.","footer":["<p>Книгу «API» можно <a href=\"index.ru.html\">читать по-русски</a>.</p>"]}},"base":"C:\\Users\\twirl_000\\Documents\\The-API-Book\\src","templates":{"pageBreak":"<div class=\"page-break\"></div>"},"anchor":"chapter-10","titleParts":["Isolating Responsibility Areas"],"localContext":null,"references":[],"title":"Chapter 10. Isolating Responsibility Areas"},"messages":[],"history":[],"cwd":"C:\\Users\\twirl_000\\Documents\\The-API-Book","value":"\n<p>Based on the previous chapter, we understand that the abstraction hierarchy in our hypothetical project would look like that:</p>\n<ul>\n<li>the user level (those entities users directly interact with and which are formulated in terms, understandable by users: orders, coffee recipes);</li>\n<li>the program execution control level (the entities responsible for transforming orders into machine commands);</li>\n<li>the runtime level for the second API kind (the entities describing the command execution state machine).</li>\n</ul>\n<p>We are now to define each entity's responsibility area: what's the reasoning in keeping this entity within our API boundaries; what operations are applicable to the entity directly (and which are delegated to other objects). In fact, we are to apply the ‘why’-principle to every single API entity.</p>\n<p>To do so we must iterate all over the API and formulate in subject area terms what every object is. Let us remind that the abstraction levels concept implies that each level is some interim subject area per se; a step we take in the journey from describing a task in the first connected context terms (‘a lungo ordered by a user’) to the second connect context terms (‘a command performed by a coffee machine’).</p>\n<p>As for our fictional example, it would look as follows.</p>\n<ol>\n<li>User-level entities.\n<ul>\n<li>An <code>order</code> describes some logical unit in app-user interaction. An <code>order</code> might be:\n<ul>\n<li>created;</li>\n<li>checked for its status;</li>\n<li>retrieved;</li>\n<li>canceled;</li>\n</ul>\n</li>\n<li>A <code>recipe</code> describes an ‘ideal model’ of some coffee beverage type, e.g. its customer properties. A <code>recipe</code> is an immutable entity for us, which means we could only read it.</li>\n<li>A <code>coffee-machine</code> is a model of a real-world device. We must be able to retrieve the coffee machine's geographical location and the options it supports from this model (which will be discussed below).</li>\n</ul>\n</li>\n<li>Program execution control level entities.\n<ul>\n<li>A <code>program</code> describes a general execution plan for a coffee machine. Programs could only be read.</li>\n<li>The <code>programs/matcher</code> entity is capable of coupling a <code>recipe</code> and a <code>program</code>, which in fact means ‘to retrieve a dataset needed to prepare a specific recipe on a specific coffee machine’.</li>\n<li>A <code>programs/run</code> entity describes a single fact of running a program on a coffee machine. A <code>run</code> might be:\n<ul>\n<li>initialized (created);</li>\n<li>checked for its status;</li>\n<li>canceled.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Runtime-level entities.\n<ul>\n<li>A <code>runtime</code> describes a specific execution data context, i.e. the state of each variable. <code>runtime</code> might be:\n<ul>\n<li>initialized (created);</li>\n<li>checked for its status;</li>\n<li>terminated.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>If we look closely at the entities, we may notice that each entity turns out to be a composite. For example, a <code>program</code> will operate high-level data (<code>recipe</code> and <code>coffee-machine</code>), enhancing them with its subject area terms (<code>program_run_id</code> for instance). This is totally fine: connecting contexts is what APIs do.</p>\n<h4>Use Case Scenarios</h4>\n<p>At this point, when our API is in general clearly outlined and drafted, we must put ourselves into the developer's shoes and try writing code. Our task is to look at the entity nomenclature and make some estimates regarding their future usage.</p>\n<p>So, let us imagine we've got a task to write an app for ordering a coffee, based on our API. What code would we write?</p>\n<p>Obviously, the first step is offering a choice to a user, to make them point out what they want. And this very first step reveals that our API is quite inconvenient. There are no methods allowing for choosing something. A developer has to implement these steps:</p>\n<ul>\n<li>retrieve all possible recipes from the <code>GET /v1/recipes</code> endpoint;</li>\n<li>retrieve a list of all available coffee machines from the <code>GET /v1/coffee-machines</code> endpoint;</li>\n<li>write a code that traverses all this data.</li>\n</ul>\n<p>If we try writing pseudocode, we will get something like that:</p>\n<pre><code>// Retrieve all possible recipes\r\nlet recipes = \r\n  api.getRecipes();\r\n// Retrieve a list of \r\n// all available coffee machines\r\nlet coffeeMachines = \r\n  api.getCoffeeMachines();\r\n// Build a spatial index\r\nlet coffeeMachineRecipesIndex = \r\n  buildGeoIndex(\r\n    recipes, \r\n    coffeeMachines\r\n  );\r\n// Select coffee machines \r\n// matching user's needs\r\nlet matchingCoffeeMachines = \r\n  coffeeMachineRecipesIndex.query(\r\n    parameters,\r\n    { \"sort_by\": \"distance\" }\r\n  );\r\n// Finally, show offers to user\r\napp.display(coffeeMachines);\n</code></pre>\n<p>As you see, developers are to write a lot of redundant code (to say nothing about the difficulties of implementing spatial indexes). Besides, if we take into consideration our Napoleonic plans to cover all coffee machines in the world with our API, then we need to admit that this algorithm is just a waste of resources on retrieving lists and indexing them.</p>\n<p>The necessity of adding a new endpoint for searching becomes obvious. To design such an interface we must imagine ourselves being UX designers, and think about how an app could try to arouse users' interest. Two scenarios are evident:</p>\n<ul>\n<li>display all cafes in the vicinity and the types of coffee they offer (a ‘service discovery’ scenario) — for new users or just users with no specific tastes;</li>\n<li>display nearby cafes where a user could order a particular type of coffee — for users seeking a certain beverage type.</li>\n</ul>\n<p>Then our new interface would look like this:</p>\n<pre><code>POST /v1/offers/search\r\n{\r\n  // optional\r\n  \"recipes\": [\"lungo\", \"americano\"],\r\n  \"position\": &#x3C;geographical coordinates>,\r\n  \"sort_by\": [\r\n    { \"field\": \"distance\" }\r\n  ],\r\n  \"limit\": 10\r\n}\r\n→\r\n{\r\n  \"results\": [\r\n    { \r\n      \"coffee_machine\", \r\n      \"place\", \r\n      \"distance\", \r\n      \"offer\" \r\n    }\r\n  ],\r\n  \"cursor\"\r\n}\n</code></pre>\n<p>Here:</p>\n<ul>\n<li>an <code>offer</code> — is a marketing bid: on what conditions a user could have the requested coffee beverage (if specified in the request), or some kind of a marketing offer — prices for the most popular or interesting products (if no specific preference was set);</li>\n<li>a <code>place</code> — is a spot (café, restaurant, street vending machine) where the coffee machine is located; we never introduced this entity before, but it's quite obvious that users need more convenient guidance to find a proper coffee machine than just geographical coordinates.</li>\n</ul>\n<p><strong>NB</strong>. We could have enriched the existing <code>/coffee-machines</code> endpoint instead of adding a new one. This decision, however, looks less semantically viable: coupling in one interface different modes of listing entities, by relevance and by order, is usually a bad idea because these two types of rankings imply different usage features and scenarios. Furthermore, enriching the search with ‘offers’ pulls this functionality out of the <code>coffee-machines</code> namespace: the fact of getting offers to prepare specific beverages in specific conditions is a key feature to users, with specifying the coffee machine being just a part of an offer.</p>\n<p>Coming back to the code developers are writing, it would now look like that:</p>\n<pre><code>// Searching for offers\r\n// matching a user's intent\r\nlet offers = api.search(parameters);\r\n// Display them to a user\r\napp.display(offers);\n</code></pre>\n<h4>Helpers</h4>\n<p>Methods similar to the newly invented <code>offers/search</code> one are called <em>helpers</em>. The purpose they exist is to generalize known API usage scenarios and facilitate implementing them. By ‘facilitating’ we mean not only reducing wordiness (getting rid of ‘boilerplates’) but also helping developers to avoid common problems and mistakes.</p>\n<p>For instance, let's consider the order price question. Our search function returns some ‘offers’ with prices. But ‘price’ is volatile; coffee could cost less during ‘happy hours’, for example. Developers could make a mistake thrice while implementing this functionality:</p>\n<ul>\n<li>cache search results on a client device for too long (as a result, the price will always be nonactual);</li>\n<li>contrary to previous, call search method excessively just to actualize prices, thus overloading the network and the API servers;</li>\n<li>create an order with an invalid price (therefore deceiving a user, displaying one sum, and debiting another).</li>\n</ul>\n<p>To solve the third problem we could demand including the displayed price in the order creation request, and return an error if it differs from the actual one. (In fact, any API working with money <em>shall</em> do so.) But it isn't helping with the first two problems and makes the user experience degrade. Displaying the actual price is always a much more convenient behavior than displaying errors upon pressing the ‘place an order’ button.</p>\n<p>One solution is to provide a special identifier to an offer. This identifier must be specified in an order creation request.</p>\n<pre><code>{\r\n  \"results\": [\r\n    {\r\n      \"coffee_machine\", \r\n      \"place\", \r\n      \"distance\",\r\n      \"offer\": {\r\n        \"id\",\r\n        \"price\",\r\n        \"currency_code\",\r\n        // Date and time \r\n        // when the offer expires\r\n        \"valid_until\"\r\n      }\r\n    }\r\n  ],\r\n  \"cursor\"\r\n}\n</code></pre>\n<p>By doing so we're not only helping developers to grasp the concept of getting the relevant price, but also solving a UX task of telling users about ‘happy hours’.</p>\n<p>As an alternative, we could split endpoints: one for searching, another one for obtaining offers. This second endpoint would only be needed to actualize prices in the specified places.</p>\n<h4>Error Handling</h4>\n<p>And one more step towards making developers' life easier: how an ‘invalid price’ error would look like?</p>\n<pre><code>POST /v1/orders\r\n{ \"offer_id\", … }\r\n→ 409 Conflict\r\n{ \"message\": \"Invalid price\" }\n</code></pre>\n<p>Formally speaking, this error response is enough: users get the ‘Invalid price’ message, and they have to repeat the order. But from a UX point of view that would be a horrible decision: the user hasn't made any mistakes, and this message isn't helpful at all.</p>\n<p>The main rule of error interfaces in the APIs is: an error response must help a client to understand <em>what to do with this error</em>. All other stuff is unimportant: if the error response was machine-readable, there would be no need for the user-readable message.</p>\n<p>An error response content must address the following questions:</p>\n<ol>\n<li>Which party is the problem's source: client or server?<br>\nHTTP APIs traditionally employ the <code>4xx</code> status codes to indicate client problems, <code>5xx</code> to indicate server problems (with the exception of the <code>404</code> code, which is an uncertainty status).</li>\n<li>If the error is caused by a server, is there any sense to repeat the request? If yes, then when?</li>\n<li>If the error is caused by a client, is it resolvable, or not?<br>\nThe invalid price error is resolvable: a client could obtain a new price offer and create a new order with it. But if the error occurred because of a mistake in the client code, then eliminating the cause is impossible, and there is no need to make the user push the ‘place an order’ button again: this request will never succeed.<br>\n<strong>NB</strong>: here and throughout we indicate resolvable problems with the <code>409 Conflict</code> code, and unresolvable ones with the <code>400 Bad Request</code> code.</li>\n<li>If the error is resolvable, then what's the kind of problem? Obviously, a client couldn't resolve a problem it's unaware of. For every resolvable problem, some <em>code</em> must be written (reobtaining the offer in our case), so a list of error descriptions must exist.</li>\n<li>If the same kind of errors arise because of different parameters being invalid, then which parameter value is wrong exactly?</li>\n<li>Finally, if some parameter value is unacceptable, then what values are acceptable?</li>\n</ol>\n<p>In our case, the price mismatch error should look like this:</p>\n<pre><code>409 Conflict\r\n{\r\n  // Error kind\r\n  \"reason\": \"offer_invalid\",\r\n  \"localized_message\":\r\n    \"Something goes wrong.⮠\r\n     Try restarting the app.\"\r\n  \"details\": {\r\n    // What's wrong exactly?\r\n    // Which validity checks failed?\r\n    \"checks_failed\": [\r\n      \"offer_lifetime\"\r\n    ]\r\n  }\r\n}\n</code></pre>\n<p>After getting this error, a client is to check the error's kind (‘some problem with offer’), check the specific error reason (‘order lifetime expired’), and send an offer retrieving request again. If the <code>checks_failed</code> field indicated another error reason (for example, the offer isn't bound to the specified user), client actions would be different (re-authorize the user, then get a new offer). If there were no error handlers for this specific reason, a client would show the <code>localized_message</code> to the user, and invoke the standard error recovery procedure.</p>\n<p>It is also worth mentioning that unresolvable errors are useless to a user at the time (since the client couldn't react usefully to unknown errors), but it doesn't mean that providing extended error data is excessive. A developer will read it when fixing the error in the code. Also, check paragraphs 12 and 13 in the next chapter.</p>\n<h4>Decomposing Interfaces. The ‘7±2’ Rule</h4>\n<p>Out of our own API development experience, we can tell without any doubt that the greatest final interface design mistake (and the greatest developers' pain accordingly) is excessive overloading of entities' interfaces with fields, methods, events, parameters, and other attributes.</p>\n<p>Meanwhile, there is the ‘Golden Rule’ of interface design (applicable not only to APIs but almost to anything): humans could comfortably keep 7±2 entities in short-term memory. Manipulating a larger number of chunks complicates things for most humans. The rule is also known as the <a href=\"https://en.wikipedia.org/wiki/Working_memory#Capacity\">‘Miller's law’</a>.</p>\n<p>The only possible method of overcoming this law is decomposition. Entities should be grouped under a single designation at every concept level of the API, so developers are never to operate more than 10 entities at a time.</p>\n<p>Let's take a look at a simple example: what the coffee machine search function returns. To ensure an adequate UX of the app, quite bulky datasets are required.</p>\n<pre><code>{\r\n  \"results\": [{\r\n    \"coffee_machine_id\",\r\n    \"coffee_machine_type\": \r\n      \"drip_coffee_maker\",\r\n    \"coffee_machine_brand\",\r\n    \"place_name\": \"The Chamomile\",\r\n    // Coordinates of a place\r\n    \"place_location_latitude\",\r\n    \"place_location_longitude\",\r\n    \"place_open_now\",\r\n    \"working_hours\",\r\n    // Walking route parameters\r\n    \"walking_distance\",\r\n    \"walking_time\",\r\n    // How to find the place\r\n    \"place_location_tip\",\r\n    \"offers\": [{\r\n      \"recipe\": \"lungo\",\r\n      \"recipe_name\": \r\n        \"Our brand new Lungo®™\",\r\n      \"recipe_description\",\r\n      \"volume\": \"800ml\",\r\n      \"offer_id\",\r\n      \"offer_valid_until\",\r\n      \"localized_price\": \r\n        \"Just $19 for a large coffee cup\",\r\n      \"price\": \"19.00\",\r\n      \"currency_code\": \"USD\",\r\n      \"estimated_waiting_time\": \"20s\"\r\n    }, …]\r\n  }, …]\r\n}\n</code></pre>\n<p>This approach is quite normal, alas; could be found in almost every API. As we see, the number of entities' fields exceeds recommended 7, and even 9. Fields are being mixed into one single list, often with similar prefixes.</p>\n<p>In this situation, we are to split this structure into data domains: which fields are logically related to a single subject area. In our case we may identify at least 7 data clusters:</p>\n<ul>\n<li>data regarding a place where the coffee machine is located;</li>\n<li>properties of the coffee machine itself;</li>\n<li>route data;</li>\n<li>recipe data;</li>\n<li>recipe options specific to the particular place;</li>\n<li>offer data;</li>\n<li>pricing data.</li>\n</ul>\n<p>Let's try to group it together:</p>\n<pre><code>{\r\n  \"results\": [{\r\n    // Place data\r\n    \"place\": { \"name\", \"location\" },\r\n    // Coffee machine properties\r\n    \"coffee-machine\": { \"id\", \"brand\", \"type\" },\r\n    // Route data\r\n    \"route\": { \r\n      \"distance\", \r\n      \"duration\", \r\n      \"location_tip\" \r\n    },\r\n    \"offers\": [{\r\n      // Recipe data\r\n      \"recipe\": { \r\n        \"id\", \r\n        \"name\", \r\n        \"description\" \r\n      },\r\n      // Recipe specific options\r\n      \"options\": \r\n        { \"volume\" },\r\n      // Offer metadata\r\n      \"offer\": \r\n        { \"id\", \"valid_until\" },\r\n      // Pricing\r\n      \"pricing\": { \r\n        \"currency_code\", \r\n        \"price\", \r\n        \"localized_price\" \r\n      },\r\n      \"estimated_waiting_time\"\r\n    }, …]\r\n  }, …]\r\n}\n</code></pre>\n<p>Such decomposed API is much easier to read than a long sheet of different attributes. Furthermore, it's probably better to group even more entities in advance. For example, a <code>place</code> and a <code>route</code> could be joined in a single <code>location</code> structure, or an <code>offer</code> and a <code>pricing</code> might be combined into some generalized object.</p>\n<p>It is important to say that readability is achieved not only by mere grouping the entities. Decomposing must be performed in such a manner that a developer, while reading the interface, instantly understands: ‘here is the place description of no interest to me right now, no need to traverse deeper’. If the data fields needed to complete some action are scattered all over different composites, the readability doesn't improve but degrades.</p>\n<p>Proper decomposition also helps with extending and evolving the API. We'll discuss the subject in Section II.</p>"}