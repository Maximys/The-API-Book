{"data":{"counter":19,"refCounter":0,"stat":{"words":32260,"characters":153801},"l10n":{"title":"The API","author":"Sergey Konstantinov","chapter":"Chapter","toc":"Table of Contents","description":"Designing APIs is a very special skill: API is a multiplier to both your opportunities and mistakes. This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.","locale":"en_US","file":"API","aboutMe":{"title":"About the Author","content":["<p>Sergey Konstantinov has been working with APIs for more than a decade. He started his career as a software engineer in the Maps API division at Yandex and eventually became the head of the service, being responsible for both technical architecture and product management.</p>","<p>During this tenure, Sergey got a unique experience in building world-class APIs with a daily audience of tens of millions, planning roadmaps for such a service, and giving numerous public speeches. He also worked for a year and a half as a member of the W3C Technical Architecture Group.</p>","<p>After nine years in Maps, Sergey switched to technical-lead roles in other departments and companies, leading integration efforts and being responsible for the technical architecture of entire business units. Today, Sergey lives in Tallinn, Estonia, and works as a staff software engineer at Bolt.</p>"],"imageCredit":"Photo by <a href=\"http://linkedin.com/in/zloylos/\">Denis Hananein</a>"},"landingFile":"index.html","url":"https://twirl.github.io/The-API-Book/","favicon":"/img/favicon.png","sidePanel":{"shareTo":"Share","copyLink":"Link","shareParameters":{"url":"https://twirl.github.io/The-API-Book/","text":"The API by Sergey Konstantinov — a book about designing APIs, extending them and finding a proper place in the market","tags":"API,TheAPIBook","viaTwitter":"blogovodoved"},"services":[{"key":"facebook","link":"https://www.facebook.com/sharer.php?u=${url}"},{"key":"twitter","link":"https://twitter.com/intent/tweet?text=${text}&url=${url}&hashtags=${tags}&via=${viaTwitter}"},{"key":"linkedin","link":"https://www.linkedin.com/sharing/share-offsite/?url=${url}"},{"key":"reddit","link":"http://www.reddit.com/submit?url=${url}&title=${text}"}]},"imageCredit":"Image Credit","links":{"email":"yatwirl@gmail.com","emailString":"yatwirl@gmail.com","linkedinHref":"https://www.linkedin.com/in/twirl/","linkedinString":"linkedin.com/in/twirl","patreonHref":"https://www.patreon.com/yatwirl","patreonString":"patreon.com/yatwirl","patreonTag":"Patreon","githubHref":"https://github.com/twirl/The-API-Book","githubString":"github.com/twirl/The-API-Book","twitterHref":"https://twitter.com/blogovodoved","kindleHref":"https://www.amazon.com/gp/product/B09RHH44S5/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i0","kindleTag":"buy Kindle version","mediumHref":"https://twirl.medium.com/","mediumTag":"Medium"},"sourceCodeAt":"Source code available at","frontPage":{"title":"The API","pageTitle":"Front Page","contents":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p class=\"text-align-left\">Illustrations &amp; inspiration by Maria Konstantinova &middot; <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a></p>","<img class=\"cc-by-nc-img\" alt=\"Creative Commons «Attribution-NonCommercial» Logo\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"/>","<p class=\"cc-by-nc\">This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.</p>"]},"landing":{"subTitle":"Free e-book","subscribeOn":"Subscribe for updates on","updates":["github"],"followOn":"Follow me on","follow":["linkedin","twitter","medium"],"supportThisWork":"Support this work on","support":["patreon","kindle"],"content":["<p>The API-first development is one of the hottest technical topics nowadays, since many companies started to realize that API serves as a multiplicator to their opportunities—but it also amplifies the design mistakes as well.</p>","<p>This book is written to share the expertise and describe the best practices in designing and developing APIs. In Section I, we'll discuss the API architecture as a concept: how to build the hierarchy properly, from high-level planning down to final interfaces. Section II is dedicated to expanding existing APIs in a backwards-compatible manner. Finally, in Section III we will talk about the API as a product.</p>","<p>Illustration &amp; inspiration: <a href=\"https://www.instagram.com/art.mari.ka/\">art.mari.ka</a>.</p>"],"download":"You might download ‘The API’ in","or":"or","readOnline":"read it online","license":"This book is distributed under the <a href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International licence</a>.","footer":["<p>Книгу «API» можно <a href=\"index.ru.html\">читать по-русски</a>.</p>"]}},"base":"C:\\Users\\twirl_000\\Documents\\The-API-Book\\src","templates":{"pageBreak":"<div class=\"page-break\"></div>"},"anchor":"chapter-18","titleParts":["Interfaces as a Universal Pattern"],"localContext":null,"references":[],"title":"Chapter 18. Interfaces as a Universal Pattern"},"messages":[],"history":[],"cwd":"C:\\Users\\twirl_000\\Documents\\The-API-Book","value":"\n<p>Let us summarize what we have written in the three previous chapters.</p>\n<ol>\n<li>Extending API functionality is realized through abstracting: the entity nomenclature is to be reinterpreted so that existing methods become partial (ideally — the most frequent) simplified cases to more general functionality.</li>\n<li>Higher-level entities are to be the informational contexts for low-level ones, e.g. don't prescribe any specific behavior but translate their state and expose functionality to modify it (directly through calling some methods or indirectly through firing events).</li>\n<li>Concrete functionality, e.g. working with ‘bare metal’ hardware or underlying platform APIs, should be delegated to low-level entities.</li>\n</ol>\n<p><strong>NB</strong>. There is nothing novel about these rules: one might easily recognize them being the <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> architecture principles. There is no surprise in that either, because SOLID concentrates on contract-oriented development, and APIs are contracts by definition. We've just added ‘abstraction levels’ and ‘informational contexts’ concepts there.</p>\n<p>However, there is an unanswered question: how should we design the entity nomenclature from the beginning so that extending the API won't make it a mess of different inconsistent methods of different ages. The answer is pretty obvious: to avoid clumsy situations while abstracting (as with the coffee machine's supported options), all the entities must be originally considered being a specific implementation of a more general interface, even if there are no planned alternative implementations for them.</p>\n<p>For example, we should have asked ourselves a question while designing the <code>POST /search</code> API: what is a ‘search result’? What abstract interface does it implement? To answer this question we must neatly decompose this entity to find which facet of it is used for interacting with which objects.</p>\n<p>Then we would have come to the understanding that a ‘search result’ is actually a composition of two interfaces:</p>\n<ul>\n<li>\n<p>when we create an order, we need from the search result to provide those fields which describe the order itself; it might be a structure like:</p>\n<p><code>{coffee_machine_id, recipe_id, volume, currency_code, price}</code>,</p>\n<p>or we can encode this data in the single <code>offer_id</code>;</p>\n</li>\n<li>\n<p>to have this search result displayed in the app, we need a different data set: <code>name</code>, <code>description</code>, formatted and localized price.</p>\n</li>\n</ul>\n<p>So our interface (let us call it <code>ISearchResult</code>) is actually a composition of two other interfaces: <code>IOrderParameters</code> (an entity that allows for creating an order) and <code>ISearchItemViewParameters</code> (some abstract representation of the search result in the UI). This interface split should automatically lead us to additional questions.</p>\n<ol>\n<li>\n<p>How will we couple the former and the latter? Obviously, these two sub-interfaces are related: the machine-readable price must match the human-readable one, for example. This will naturally lead us to the ‘formatter’ concept described in the <a href=\"#chapter-16\">Chapter 16</a>.</p>\n</li>\n<li>\n<p>And what is the ‘abstract representation of the search result in the UI’? Do we have other kinds of search, should the <code>ISearchItemViewParameters</code> interface be a subtype of some even more general interface, or maybe a composition of several such ones?</p>\n</li>\n</ol>\n<p>Replacing specific implementations with interfaces not only allows us to answer more clearly many questions which should have popped out in the API design phase but also helps us to outline many possible API evolution vectors, which should help in avoiding API inconsistency problems in the future.</p>"}